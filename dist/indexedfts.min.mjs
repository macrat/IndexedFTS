function splitText(e,r=2){const t=[];for(let n=0;n<e.length-r+1;n++)t.push(e.slice(n,n+r));return t}function splitWords(e){return dedup(e.split(/\s+/).filter(e=>e.length>0))}function tokenize(e,r=2){return dedup(splitText(e,r))}function splitQuery(e,r=2){const t={};return e.split(/\s+/).filter(e=>e.length>0).forEach(e=>t[e]=tokenize(e,r)),t}function dedup(e){const r=new Array(e.length),t=new Set;let n=0;for(let s=0;s<e.length;s++)t.has(e[s])||(t.add(e[s]),r[n]=e[s],n++);return r.slice(0,n)}function fastMap(e,r){const t=new Array(e.length);for(let n=0;n<e.length;n++)t[n]=r(e[n]);return t}function flatten(e){let r=0;for(let t=0;t<e.length;t++)r+=e[t].length;const t=new Array(r);let n=0;for(let r=0;r<e.length;r++)for(let s=0;s<e[r].length;s++)t[n]=e[r][s],n++;return t}class NoSuchColumnError extends Error{constructor(e){super(e+": no such column or no indexed"),this.column=e,this.name="",Error.captureStackTrace&&Error.captureStackTrace(this,NoSuchColumnError)}}class InvalidKeyError extends Error{constructor(e){super("invalid key"),this.key=e,this.name="",Error.captureStackTrace&&Error.captureStackTrace(this,InvalidKeyError)}}class InvalidSchemaError extends Error{constructor(e,r=null){super(e),this.column=r,this.name="InvalidSchemaError",Error.captureStackTrace&&Error.captureStackTrace(this,InvalidSchemaError)}}class IFTSArrayPromise{constructor(e,r){this.indexes=e,this.promise=r}static resolve(e,r=[]){return new IFTSArrayPromise(e,Promise.resolve(r))}static reject(e,r=null){return new IFTSArrayPromise(e,Promise.reject(r))}then(e){return this.promise.then(e)}catch(e){return this.promise.catch(e)}map(e){return new IFTSArrayPromise(this.indexes,this.then(r=>r.map(e)))}filter(e){return new IFTSArrayPromise(this.indexes,this.then(r=>r.filter(e)))}sort(e,r="asc",t=0,n){return this.indexes.has(e)?new IFTSArrayPromise(this.indexes,this.then(s=>Array.prototype.concat.call([],s).sort((t,n)=>t[e]<n[e]?"desc"===r?1:-1:t[e]>n[e]?"desc"===r?-1:1:0).slice(t,void 0===n?void 0:t+n))):IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(e))}_checkAndFilter(e,r){return this.indexes.has(e)?this.filter(r):IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(e))}equals(e,r){return this._checkAndFilter(e,t=>t[e]===r)}lower(e,r){return this._checkAndFilter(e,t=>t[e]<r)}greater(e,r){return this._checkAndFilter(e,t=>t[e]>r)}lowerOrEquals(e,r){return this._checkAndFilter(e,t=>t[e]<=r)}greaterOrEquals(e,r){return this._checkAndFilter(e,t=>t[e]>=r)}between(e,r,t){return this._checkAndFilter(e,n=>r<=n[e]&&n[e]<=t)}search(e,r,t={}){"string"==typeof e&&(e=[e]);for(let r of e)if(!this.indexes.has(r))return IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(r));r=t.ignoreCase?r.toLowerCase():r;const n=[];for(let e in splitQuery(r))n.push(e);const s=t.ignoreCase?e=>e.toLowerCase():e=>e;return this.filter(r=>n.every(t=>e.some(e=>s(r[e]).includes(t))))}searchWord(e,r,t={}){"string"==typeof e&&(e=[e]);for(let r of e)if(!this.indexes.has(r))return IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(r));const n=splitWords(r=t.ignoreCase?r.toLowerCase():r),s=t.ignoreCase?e=>e.toLowerCase():e=>e;return this.filter(r=>n.every(t=>e.some(e=>splitWords(s(r[e])).includes(t))))}}class IFTSTransaction{constructor(e,r){this.db=e,this.transaction=r,this._KeyRange=this.db.scope.IDBKeyRange,this.promise=new Promise((e,r)=>{this.transaction.oncomplete=(()=>e(this.db)),this.transaction.onerror=(e=>r(e))}),this._cache={}}put(...e){const r=this.transaction.objectStore("data"),t=fastMap([...this.db.schema.ngramIndexes],e=>({name:e,store:this.transaction.objectStore(this.db.index_prefix+"ngram_"+e)})),n=fastMap([...this.db.schema.wordIndexes],e=>({name:e,store:this.transaction.objectStore(this.db.index_prefix+"word_"+e)})),s=new Array(e.length);for(let o=0;o<e.length;o++)s[o]=new Promise((s,i)=>{const a=r.put(e[o]);a.onerror=i,a.onsuccess=(r=>{s(this._updateNGramIndex(r.target.result,e[o],t).then(()=>this._updateWordIndex(r.target.result,e[o],n)))})});return Promise.all(s).then(e=>{for(let r=0;r<e.length;r++){const t=e[r][0],n=e[r][1];null===this.db.schema.primaryKey&&(n._key=t),this._cache[t]=n}return this})}_updateNGramIndex(e,r,t){return this._deleteIndex(e,t.map(e=>this.db.index_prefix+"ngram_"+e.name)).then(()=>Promise.all(fastMap(t,t=>{const n=tokenize(r[t.name]),s=new Array(n.length);for(let r=0;r<n.length;r++)s[r]=new Promise((s,o)=>{const i=t.store.put({key:e,token:n[r],lower:n[r].toLowerCase()});i.onsuccess=(()=>s()),i.onerror=o});return Promise.all(s)}))).then(()=>[e,r])}_updateWordIndex(e,r,t){return this._deleteIndex(e,t.map(e=>this.db.index_prefix+"word_"+e.name)).then(()=>Promise.all(fastMap(t,t=>{const n=splitWords(r[t.name]),s=new Array(n.length);for(let r=0;r<n.length;r++)s[r]=new Promise((s,o)=>{const i=t.store.put({key:e,word:n[r],lower:n[r].toLowerCase()});i.onsuccess=(()=>s()),i.onerror=o});return Promise.all(s)}))).then(()=>[e,r])}_deleteIndex(e,r){return Promise.all(r.map(r=>new Promise((t,n)=>{const s=this.transaction.objectStore(r);s.onerror=n;const o=[],i=s.index("key").openKeyCursor(this._KeyRange.only(e));i.onerror=n,i.onsuccess=(e=>{const r=e.target.result;r?(o.push(new Promise((e,t)=>{const n=s.delete(r.primaryKey);n.onsuccess=e,n.onerror=t})),r.continue()):t(Promise.all(o))})})))}delete(...e){for(let r=0;r<e.length;r++)if(null===e[r]||void 0===e[r])return Promise.reject(new InvalidKeyError(e[r]));return Promise.all(fastMap(e,e=>new Promise((r,t)=>{const n=this.transaction.objectStore("data").delete(e);n.onerror=t,n.onsuccess=r}).then(()=>this._deleteIndex(e,[...[...this.db.schema.ngramIndexes].map(e=>this.db.index_prefix+"ngram_"+e),...[...this.db.schema.wordIndexes].map(e=>this.db.index_prefix+"word_"+e)])))).then(()=>this)}_readCursor(e,r=null,t=null,n){return r=r||((e,r)=>!0),t=t||((e,r)=>e),new IFTSArrayPromise(this.db.schema.indexes,new Promise((s,o)=>{const i=[];let a=0;e.onsuccess=(e=>{const o=e.target.result;if(o){const e=o.value;null===this.db.schema.primaryKey&&(e._key=o.key),this._cache[o.key]=e,r(e,a)&&i.push(t(e,a)),a++,void 0===n||a<n?o.continue():s(i)}else s(i)}),e.onerror=(e=>o(e))}))}getAll(){return this._readCursor(this.transaction.objectStore("data").openCursor())}_getAllWithKeys(){return new IFTSArrayPromise(this.db.schema.indexes,new Promise((e,r)=>{const t=this.transaction.objectStore("data").openCursor(),n=[];t.onsuccess=(r=>{const t=r.target.result;if(t){const e=t.value;null===this.db.schema.primaryKey&&(e._key=t.key),this._cache[t.key]=e,n.push({key:t.key,data:e}),t.continue()}else e(n)}),t.onerror=(e=>r(e))}))}map(e){return this._readCursor(this.transaction.objectStore("data").openCursor(null),null,e)}filter(e){return this._readCursor(this.transaction.objectStore("data").openCursor(null),e,null)}sort(e,r="asc",t=0,n){if(!this.db.schema.indexes.has(e))return IFTSArrayPromise.reject(this.db.schema.indexes,new NoSuchColumnError(e));n=void 0===n?void 0:t+n;const s=(e,r)=>t<=r,o=this.transaction.objectStore("data");return e===this.db.schema.primaryKey?this._readCursor(o.openCursor(null,"desc"===r?"prev":"next"),s,null,n):this._readCursor(o.index(e).openCursor(null,"desc"===r?"prev":"next"),s,null,n)}get(e){return null===e||void 0===e?Promise.reject(new InvalidKeyError(e)):e in this._cache?Promise.resolve(this._cache[e]):new Promise((r,t)=>{const n=this.transaction.objectStore("data").get(e);n.onsuccess=(t=>{const n=t.target.result;null===this.db.schema.primaryKey&&(n._key=e),this._cache[e]=n,r(n)}),n.onerror=t})}_getAllWithIndex(e,r){if(!this.db.schema.indexes.has(e))return IFTSArrayPromise.reject(this.db.schema.indexes,new NoSuchColumnError(e));const t=this.transaction.objectStore("data");return e===this.db.schema.primaryKey?this._readCursor(t.openCursor(r)):this._readCursor(t.index(e).openCursor(r))}equals(e,r){return this._getAllWithIndex(e,this._KeyRange.only(r))}lower(e,r){return this._getAllWithIndex(e,this._KeyRange.upperBound(r,!0))}greater(e,r){return this._getAllWithIndex(e,this._KeyRange.lowerBound(r,!0))}lowerOrEquals(e,r){return this._getAllWithIndex(e,this._KeyRange.upperBound(r,!1))}greaterOrEquals(e,r){return this._getAllWithIndex(e,this._KeyRange.lowerBound(r,!1))}between(e,r,t){return this._getAllWithIndex(e,this._KeyRange.bound(r,t,!1,!1))}_takeCandidatesBySingleColumn(e,r,t={}){const n=this.transaction.objectStore(this.db.index_prefix+"ngram_"+e),s=t.ignoreCase?n.index("lower"):n.index("token"),o=[];for(let n in r){const i=t.ignoreCase?r=>r.data[e].toLowerCase().includes(n):r=>r.data[e].includes(n);if(0===r[n].length){o.push(this._getAllWithKeys().filter(i).map(e=>e.key).then(e=>({query:n,keys:e})));continue}const a=new Array(r[n].length);for(let e=0;e<r[n].length;e++)a[e]=this._readCursor(s.openCursor(r[n][e]),null,e=>e.key);const h=Promise.all(a).then(e=>{if(0===e.length)return Promise.resolve([]);e=flatten(e);const t=new Array(e.length);let s=0;const o={};for(let r=0;r<e.length;r++)e[r]in o||(o[e[r]]=0,t[s]=e[r],s++),o[e[r]]++;const i=new Array(s);let a=0;for(let e=0;e<s;e++)o[t[e]]>=r[n].length&&(i[a]=this.get(t[e]).then(r=>({key:t[e],data:r})),a++);return Promise.all(i.slice(0,a))}).then(e=>({query:n,keys:e.filter(i).map(e=>e.key)}));o.push(h)}return o}async _pruneCandidates(e,r){const t={};for(let e=0;e<r.length;e++)for(let n=0;n<r[e].keys.length;n++)r[e].keys[n]in t||(t[r[e].keys[n]]=new Set),t[r[e].keys[n]].add(r[e].query);const n=new Array(r.length);let s=0;for(let r in t)t[r].size==e&&(n[s]=this.get(r),s++);return await Promise.all(n.slice(0,s))}search(e,r,t={}){"string"==typeof e&&(e=[e]);for(let r=0;r<e.length;r++)if(!this.db.schema.ngramIndexes.has(e[r]))return IFTSArrayPromise.reject(this.db.schema.indexes,new NoSuchColumnError(e[r]));const n=splitQuery(r=t.ignoreCase?r.toLowerCase():r);let s=0;for(let e in n)n[e]=fastMap(n[e],e=>this._KeyRange.only(e)),s++;const o=[];for(let r=0;r<e.length;r++)Array.prototype.push.apply(o,this._takeCandidatesBySingleColumn(e[r],n,t));return new IFTSArrayPromise(this.db.schema.indexes,Promise.all(o).then(e=>this._pruneCandidates(s,e)))}searchWord(e,r,t={}){"string"==typeof e&&(e=[e]);for(let r=0;r<e.length;r++)if(!this.db.schema.wordIndexes.has(e[r]))return IFTSArrayPromise.reject(this.db.schema.indexes,new NoSuchColumnError(e[r]));const n=splitWords(r=t.ignoreCase?r.toLowerCase():r).map(e=>({text:e,keyRange:this._KeyRange.only(e)}));return new IFTSArrayPromise(this.db.schema.indexes,Promise.all(flatten(e.map(e=>{const r=this.transaction.objectStore(this.db.index_prefix+"word_"+e),s=t.ignoreCase?r.index("lower"):r.index("word");return n.map(e=>this._readCursor(s.openCursor(e.keyRange),null,r=>[r.key,e.text]))}))).then(e=>{e=dedup(flatten(e));const r={};for(let t=0;t<e.length;t++){const n=e[t][0];n in r||(r[n]=0),r[n]++}const t=new Array(e.length);let s=0;for(let o=0;o<e.length;o++){const i=e[o][0];r[i]>=n.length&&(t[s]=i,s++)}const o=new Array(s);for(let e=0;e<s;e++)o[e]=this.get(t[e]);return new IFTSArrayPromise(this.db.schema.indexes,Promise.all(o))}))}_readIndexSet(e){const r=new Map;return new Promise((t,n)=>{const s=e.openKeyCursor();s.onsuccess=(e=>{const n=e.target.result;n?(r.set(n.key,(r.get(n.key)||0)+1),n.continue()):t(r)}),s.onerror=(e=>n(e))})}getNGrams(e,r={}){if(!this.db.schema.ngramIndexes.has(e))return Promise.reject(new NoSuchColumnError(e));const t=this.transaction.objectStore(this.db.index_prefix+"ngram_"+e),n=r.ignoreCase?t.index("lower"):t.index("token");return this._readIndexSet(n)}getWords(e,r={}){if(!this.db.schema.wordIndexes.has(e))return Promise.reject(new NoSuchColumnError(e));const t=this.transaction.objectStore(this.db.index_prefix+"word_"+e),n=r.ignoreCase?t.index("lower"):t.index("word");return this._readIndexSet(n)}}function normalize(e){const r=new Set(["primary","unique","ngram","fulltext","word"]),t={};for(const n in e)if(t[n]={},"object"==typeof e[n])for(const s in e[n]){if(!r.has(s))throw new InvalidSchemaError(s+" is unknown option",n);t[n][s]=e[n][s]}else{if("string"!=typeof e[n])throw new InvalidSchemaError(typeof e[n]+" is invalid option type",n);if(!r.has(e[n]))throw new InvalidSchemaError(e[n]+" is unknown option",n);t[n][e[n]]=!0}return t}function schemaCheck(e){let r=null;for(const t in e){if(void 0!==e[t].primary){if("boolean"!=typeof e[t].primary)throw new InvalidSchemaError('"primary" option must be boolean',t);if(e[t].primary){if(null!==r)throw new InvalidSchemaError("can not use multiple primary key",[t,r]);r=t}}if(void 0!==e[t].unique&&"boolean"!=typeof e[t].unique)throw new InvalidSchemaError('"unique" option must be boolean',t);if(e[t].primary&&e[t].unique)throw new InvalidSchemaError('can not enable both of "primary" option and "unique" option to same column',t);if(void 0!==e[t].ngram&&void 0!==e[t].fulltext)throw new InvalidSchemaError('can not set both of "ngram" option and "fulltext" option to same column',t);const n=void 0===e[t].ngram?e[t].fulltext:e[t].ngram,s=void 0===e[t].ngram?"fulltext":"ngram";if(void 0!==n&&"boolean"!=typeof n)throw new InvalidSchemaError(`"${s}" option must be boolean`,t);if(void 0!==e[t].word&&"boolean"!=typeof e[t].word)throw new InvalidSchemaError('"word" option must be boolean',t)}}class IFTSSchema{constructor(e){this._schema=normalize(e),this._storeOption={autoIncrement:!0},this.primaryKey=null,this.ngramIndexes=new Set,this.wordIndexes=new Set,this.uniqueIndexes=new Set,this.normalIndexes=new Set;for(let r in e)schemaCheck(this._schema),this._schema[r].primary?(this.primaryKey=r,this._storeOption={keyPath:r}):this._schema[r].unique?this.uniqueIndexes.add(r):this.normalIndexes.add(r),(this._schema[r].ngram||this._schema[r].fulltext)&&this.ngramIndexes.add(r),this._schema[r].word&&this.wordIndexes.add(r)}get indexes(){return this.primaryKey?new Set([this.primaryKey,...this.uniqueIndexes,...this.normalIndexes]):new Set([...this.uniqueIndexes,...this.normalIndexes])}}class IndexedFTS{constructor(e,r,t,n={}){this.index_prefix=n.index_prefix||"indexedfts_",this.scope=n.scope||window,this.name=e,this.version=r,this.schema=t instanceof IFTSSchema?t:new IFTSSchema(t),this.db=null}static delete(e,r=null){return new Promise((t,n)=>{const s=(r||window).indexedDB.deleteDatabase(e);s.onsuccess=(e=>t()),s.onerror=(e=>n(e))})}open(){return new Promise((e,r)=>{const t=this.scope.indexedDB.open(this.name,this.version);t.onsuccess=(r=>{this.db=r.target.result,e(this)}),t.onerror=r,t.onupgradeneeded=(e=>{this.db=e.target.result;const t=this.db.createObjectStore("data",this.schema._storeOption);t.onerror=r,this.schema.uniqueIndexes.forEach(e=>t.createIndex(e,e,{unique:!0})),this.schema.normalIndexes.forEach(e=>t.createIndex(e,e,{unique:!1})),this.schema.ngramIndexes.forEach(e=>{const t=this.db.createObjectStore(this.index_prefix+"ngram_"+e,{autoIncrement:!0});t.onerror=r,t.createIndex("key","key",{unique:!1}),t.createIndex("token","token",{unique:!1}),t.createIndex("lower","lower",{unique:!1})}),this.schema.wordIndexes.forEach(e=>{const t=this.db.createObjectStore(this.index_prefix+"word_"+e,{autoIncrement:!0});t.onerror=r,t.createIndex("key","key",{unique:!1}),t.createIndex("word","word",{unique:!1}),t.createIndex("lower","lower",{unique:!1})})})})}close(){this.db.close()}transaction(e="readonly",r=null){if(null===r){const e=[...this.schema.ngramIndexes].map(e=>this.index_prefix+"ngram_"+e),t=[...this.schema.wordIndexes].map(e=>this.index_prefix+"word_"+e);r=e.concat(t).concat(["data"])}return new IFTSTransaction(this,this.db.transaction(r,e))}put(...e){return this.transaction("readwrite").put(...e).then(()=>this)}delete(...e){return this.transaction("readwrite").delete(...e).then(()=>this)}get(e){return this.transaction("readonly","data").get(e)}_getFiltered(e){return e(this.transaction("readonly","data"))}getAll(){return this._getFiltered(e=>e.getAll())}map(e){return this._getFiltered(r=>r.map(e))}filter(e){return this._getFiltered(r=>r.filter(e))}sort(e,r="asc",t=0,n){return this._getFiltered(s=>s.sort(e,r,t,n))}equals(e,r){return this._getFiltered(t=>t.equals(e,r))}lower(e,r){return this._getFiltered(t=>t.lower(e,r))}greater(e,r){return this._getFiltered(t=>t.greater(e,r))}lowerOrEquals(e,r){return this._getFiltered(t=>t.lowerOrEquals(e,r))}greaterOrEquals(e,r){return this._getFiltered(t=>t.greaterOrEquals(e,r))}between(e,r,t){return this._getFiltered(n=>n.between(e,r,t))}search(e,r,t={}){return this.transaction().search(e,r,t)}searchWord(e,r,t={}){return this.transaction().searchWord(e,r,t)}getNGrams(e,r={}){return this.transaction().getNGrams(e,r)}getWords(e,r={}){return this.transaction().getWords(e,r)}}export default IndexedFTS;export{IFTSTransaction,IFTSArrayPromise,IFTSSchema,NoSuchColumnError,InvalidKeyError,InvalidSchemaError};
//# sourceMappingURL=indexedfts.min.mjs.map
