function splitText(e,t=2){const r=[];for(let n=0;n<e.length-t+1;n++)r.push(e.slice(n,n+t));return r}function tokenize(e,t=2){return dedup(splitText(e,t))}function splitQuery(e,t=2){const r={};return e.split(/\s+/).filter(e=>e.length>0).forEach(e=>r[e]=tokenize(e,t)),r}function dedup(e){const t=new Array(e.length),r=new Set;let n=0;for(let s=0;s<e.length;s++)r.has(e[s])||(r.add(e[s]),t[n]=e[s],n++);return t.slice(0,n)}function fastMap(e,t){const r=new Array(e.length);for(let n=0;n<e.length;n++)r[n]=t(e[n]);return r}function flatten(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r].length;const r=new Array(t);let n=0;for(let t=0;t<e.length;t++)for(let s=0;s<e[t].length;s++)r[n]=e[t][s],n++;return r}class NoSuchColumnError extends Error{constructor(e){super(e+": no such column or no indexed"),this.column=e,this.name="",Error.captureStackTrace&&Error.captureStackTrace(this,NoSuchColumnError)}}class InvalidKeyError extends Error{constructor(e){super("invalid key"),this.key=e,this.name="",Error.captureStackTrace&&Error.captureStackTrace(this,InvalidKeyError)}}class IFTSArrayPromise{constructor(e,t){this.indexes=e,this.promise=t}static resolve(e,t=[]){return new IFTSArrayPromise(e,Promise.resolve(t))}static reject(e,t=null){return new IFTSArrayPromise(e,Promise.reject(t))}then(e){return this.promise.then(e)}catch(e){return this.promise.catch(e)}map(e){return new IFTSArrayPromise(this.indexes,this.then(t=>t.map(e)))}filter(e){return new IFTSArrayPromise(this.indexes,this.then(t=>t.filter(e)))}sort(e,t="asc",r=0,n){return this.indexes.has(e)?new IFTSArrayPromise(this.indexes,this.then(s=>Array.prototype.concat.call([],s).sort((r,n)=>r[e]<n[e]?"desc"===t?1:-1:r[e]>n[e]?"desc"===t?-1:1:0).slice(r,void 0===n?void 0:r+n))):IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(e))}_checkAndFilter(e,t){return this.indexes.has(e)?this.filter(t):IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(e))}equals(e,t){return this._checkAndFilter(e,r=>r[e]===t)}lower(e,t){return this._checkAndFilter(e,r=>r[e]<t)}greater(e,t){return this._checkAndFilter(e,r=>r[e]>t)}lowerOrEquals(e,t){return this._checkAndFilter(e,r=>r[e]<=t)}greaterOrEquals(e,t){return this._checkAndFilter(e,r=>r[e]>=t)}between(e,t,r){return this._checkAndFilter(e,n=>t<=n[e]&&n[e]<=r)}search(e,t){"string"==typeof e&&(e=[e]);for(let t of e)if(!this.indexes.has(t))return IFTSArrayPromise.reject(this.indexes,new NoSuchColumnError(t));const r=[];for(let e in splitQuery(t))r.push(e);return this.filter(t=>r.every(r=>e.some(e=>t[e].includes(r))))}}class IFTSTransaction{constructor(e,t){this.db=e,this.transaction=t,this._KeyRange=this.db.scope.IDBKeyRange,this.promise=new Promise((e,t)=>{this.transaction.oncomplete=(()=>e(this.db)),this.transaction.onerror=(e=>t(e))}),this._cache={}}put(...e){const t=this.transaction.objectStore("data"),r=fastMap([...this.db.fulltext_indexes],e=>({name:e,store:this.transaction.objectStore(this.db.index_prefix+e)})),n=new Array(e.length);for(let s=0;s<e.length;s++)n[s]=new Promise((n,i)=>{const o=t.put(e[s]);o.onerror=i,o.onsuccess=(t=>n(this._updateIndex(t.target.result,e[s],r)))});return Promise.all(n).then(e=>{for(let t=0;t<e.length;t++){const r=e[t][0],n=e[t][1];null===this.db.primary_key&&(n._key=r),this._cache[r]=n}return this})}_updateIndex(e,t,r){return this._deleteIndex(e).then(()=>Promise.all(fastMap(r,r=>{const n=tokenize(t[r.name]),s=new Array(n.length);for(let t=0;t<n.length;t++)s[t]=new Promise((s,i)=>{const o=r.store.put({key:e,token:n[t]});o.onsuccess=(()=>s()),o.onerror=i});return Promise.all(s)}))).then(()=>[e,t])}_deleteIndex(e){return Promise.all([...this.db.fulltext_indexes].map(t=>new Promise((r,n)=>{const s=this.transaction.objectStore(this.db.index_prefix+t);s.onerror=n;const i=[],o=s.index("key").openKeyCursor(this._KeyRange.only(e));o.onerror=n,o.onsuccess=(e=>{const t=e.target.result;t?(i.push(new Promise((e,r)=>{const n=s.delete(t.primaryKey);n.onsuccess=e,n.onerror=r})),t.continue()):r(Promise.all(i))})})))}delete(...e){for(let t=0;t<e.length;t++)if(null===e[t]||void 0===e[t])return Promise.reject(new InvalidKeyError(e[t]));return Promise.all(fastMap(e,e=>new Promise((t,r)=>{const n=this.transaction.objectStore("data").delete(e);n.onerror=r,n.onsuccess=t}).then(()=>this._deleteIndex(e)))).then(()=>this)}_readCursor(e,t=null,r=null){return t=t||(e=>!0),r=r||(e=>e),new IFTSArrayPromise(this.db.indexes,new Promise((n,s)=>{const i=[];e.onsuccess=(e=>{const s=e.target.result;if(s){const e=s.value;null===this.db.primary_key&&(e._key=s.key),this._cache[s.key]=e,t(e)&&i.push(r(e)),s.continue()}else n(i)}),e.onerror=(e=>s(e))}))}getAll(){return this._readCursor(this.transaction.objectStore("data").openCursor())}_getAllWithKeys(){return new IFTSArrayPromise(this.db.indexes,new Promise((e,t)=>{const r=this.transaction.objectStore("data").openCursor(),n=[];r.onsuccess=(t=>{const r=t.target.result;if(r){const e=r.value;null===this.db.primary_key&&(e._key=r.key),this._cache[r.key]=e,n.push({key:r.key,data:e}),r.continue()}else e(n)}),r.onerror=(e=>t(e))}))}map(e){return this._readCursor(this.transaction.objectStore("data").openCursor(null),null,e)}filter(e){return this._readCursor(this.transaction.objectStore("data").openCursor(null),e,null)}sort(e,t="asc",r=0,n){if(!this.db.indexes.has(e))return IFTSArrayPromise.reject(this.db.indexes,new NoSuchColumnError(e));let s=0;const i=()=>{const e=r<=s&&(void 0===n||s<r+n);return s++,e},o=this.transaction.objectStore("data");return e===this.db.primary_key?this._readCursor(o.openCursor(null,"desc"===t?"prev":"next"),i):this._readCursor(o.index(e).openCursor(null,"desc"===t?"prev":"next"),i)}get(e){return null===e||void 0===e?Promise.reject(new InvalidKeyError(e)):e in this._cache?Promise.resolve(this._cache[e]):new Promise((t,r)=>{const n=this.transaction.objectStore("data").get(e);n.onsuccess=(r=>{const n=r.target.result;null===this.db.primary_key&&(n._key=e),this._cache[e]=n,t(n)}),n.onerror=r})}_getAllWithIndex(e,t){if(!this.db.indexes.has(e))return IFTSArrayPromise.reject(this.db.indexes,new NoSuchColumnError(e));const r=this.transaction.objectStore("data");return e===this.db.primary_key?this._readCursor(r.openCursor(t)):this._readCursor(r.index(e).openCursor(t))}equals(e,t){return this._getAllWithIndex(e,this._KeyRange.only(t))}lower(e,t){return this._getAllWithIndex(e,this._KeyRange.upperBound(t,!0))}greater(e,t){return this._getAllWithIndex(e,this._KeyRange.lowerBound(t,!0))}lowerOrEquals(e,t){return this._getAllWithIndex(e,this._KeyRange.upperBound(t,!1))}greaterOrEquals(e,t){return this._getAllWithIndex(e,this._KeyRange.lowerBound(t,!1))}between(e,t,r){return this._getAllWithIndex(e,this._KeyRange.bound(t,r,!1,!1))}_takeCandidatesBySingleColumn(e,t){const r=this.transaction.objectStore(this.db.index_prefix+e).index("token"),n=[];for(let s in t){if(0===t[s].length){n.push(this._getAllWithKeys().filter(t=>t.data[e].includes(s)).map(e=>e.key).then(e=>({query:s,keys:e})));continue}const i=new Array(t[s].length);for(let e=0;e<t[s].length;e++)i[e]=this._readCursor(r.openCursor(t[s][e])).map(e=>e.key);const o=Promise.all(i).then(e=>{if(0===e.length)return Promise.resolve([]);e=flatten(e);const r=new Array(e.length);let n=0;const i={};for(let t=0;t<e.length;t++)e[t]in i||(i[e[t]]=0,r[n]=e[t],n++),i[e[t]]++;const o=new Array(n);let a=0;for(let e=0;e<n;e++)i[r[e]]>=t[s].length&&(o[a]=this.get(r[e]).then(t=>({key:r[e],data:t})),a++);return Promise.all(o.slice(0,a))}).then(t=>({query:s,keys:t.filter(t=>t.data[e].includes(s)).map(e=>e.key)}));n.push(o)}return n}async _pruneCandidates(e,t){const r={};for(let e=0;e<t.length;e++)for(let n=0;n<t[e].keys.length;n++)t[e].keys[n]in r||(r[t[e].keys[n]]=new Set),r[t[e].keys[n]].add(t[e].query);const n=new Array(t.length);let s=0;for(let t in r)r[t].size==e&&(n[s]=this.get(t),s++);return await Promise.all(n.slice(0,s))}search(e,t){"string"==typeof e&&(e=[e]);for(let t=0;t<e.length;t++)if(!this.db.fulltext_indexes.has(e[t]))return IFTSArrayPromise.reject(this.db.indexes,new NoSuchColumnError(e[t]));const r=splitQuery(t);let n=0;for(let e in r)r[e]=fastMap(r[e],e=>this._KeyRange.only(e)),n++;const s=[];for(let t=0;t<e.length;t++)Array.prototype.push.apply(s,this._takeCandidatesBySingleColumn(e[t],r));return new IFTSArrayPromise(this.db.indexes,Promise.all(s).then(e=>this._pruneCandidates(n,e)))}}class IndexedFTS{constructor(e,t,r,n={}){this.index_prefix=n.index_prefix||"indexedfts_",this.scope=n.scope||window,this.name=e,this.version=t,this.schema=r,this.store_option={autoIncrement:!0},this.primary_key=null,this.fulltext_indexes=new Set,this.unique_indexes=new Set,this.normal_indexes=new Set,this.db=null;for(let e in r){if("primary"===r[e]||r[e].primary){if("keyPath"in this.store_option)throw new Error("can not use multi primary key");this.primary_key=e,this.store_option={keyPath:e}}else"unique"===r[e]||r[e].unique?this.unique_indexes.add(e):this.normal_indexes.add(e);("fulltext"===r[e]||r[e].fulltext)&&this.fulltext_indexes.add(e)}}get indexes(){const e=new Set([...this.fulltext_indexes,...this.unique_indexes,...this.normal_indexes]);return null!==this.primary_key&&e.add(this.primary_key),e}open(){return new Promise((e,t)=>{const r=this.scope.indexedDB.open(this.name,this.version);r.onsuccess=(t=>{this.db=t.target.result,e(this)}),r.onerror=t,r.onupgradeneeded=(e=>{this.db=e.target.result;const r=this.db.createObjectStore("data",this.store_option);r.onerror=t,this.unique_indexes.forEach(e=>r.createIndex(e,e,{unique:!0})),this.normal_indexes.forEach(e=>r.createIndex(e,e,{unique:!1})),this.fulltext_indexes.forEach(e=>{const r=this.db.createObjectStore(this.index_prefix+e,{autoIncrement:!0});r.onerror=t,r.createIndex("key","key",{unique:!1}),r.createIndex("token","token",{unique:!1}),r.createIndex("uni",["key","token"],{unique:!0})})})})}close(){this.db.close()}transaction(e="readonly",t=null){return null===t&&(t=[...this.fulltext_indexes].map(e=>this.index_prefix+e).concat(["data"])),new IFTSTransaction(this,this.db.transaction(t,e))}put(...e){return this.transaction("readwrite").put(...e).then(()=>this)}delete(...e){return this.transaction("readwrite").delete(...e).then(()=>this)}get(e){return this.transaction("readonly","data").get(e)}_getFiltered(e){return e(this.transaction("readonly","data"))}getAll(){return this._getFiltered(e=>e.getAll())}map(e){return this._getFiltered(t=>t.map(e))}filter(e){return this._getFiltered(t=>t.filter(e))}sort(e,t="asc",r=0,n){return this._getFiltered(s=>s.sort(e,t,r,n))}equals(e,t){return this._getFiltered(r=>r.equals(e,t))}lower(e,t){return this._getFiltered(r=>r.lower(e,t))}greater(e,t){return this._getFiltered(r=>r.greater(e,t))}lowerOrEquals(e,t){return this._getFiltered(r=>r.lowerOrEquals(e,t))}greaterOrEquals(e,t){return this._getFiltered(r=>r.greaterOrEquals(e,t))}between(e,t,r){return this._getFiltered(n=>n.between(e,t,r))}search(e,t){return this.transaction().search(e,t)}}export default IndexedFTS;export{IFTSTransaction,IFTSArrayPromise,NoSuchColumnError,InvalidKeyError};
