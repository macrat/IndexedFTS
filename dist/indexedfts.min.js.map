{"version":3,"file":"indexedfts.min.js","sources":["../lib/utils.js","../lib/errors.js","../lib/IFTSArrayPromise.js","../lib/IFTSTransaction.js","../lib/IndexedFTS.js"],"sourcesContent":["/**\n * Splitting text to n-gram\n *\n * @ignore\n */\nexport function splitText(text, ngram=2) {\n\tconst result = [];\n\tfor (let i=0; i<text.length-ngram+1; i++) {\n\t\tresult.push(text.slice(i, i+ngram));\n\t}\n\treturn result;\n}\n\n\n/**\n * Splitting text to words\n *\n * @ignore\n */\nexport function splitWords(text) {\n\treturn dedup(text.split(/\\s+/).filter(x => x.length > 0));\n}\n\n\n/**\n * Make n-gram set by text.\n *\n * @ignore\n */\nexport function tokenize(text, ngram=2) {\n\treturn dedup(splitText(text, ngram));\n}\n\n\n/**\n * Parse queries.\n *\n * @ignore\n */\nexport function splitQuery(query, ngram=2) {\n\tconst result = {};\n\tquery.split(/\\s+/).filter(q => q.length > 0).forEach(q => result[q] = tokenize(q, ngram));\n\treturn result;\n}\n\n\n/**\n * Deduplication from Array\n *\n * @ignore\n */\nexport function dedup(array) {\n\tconst result = new Array(array.length);\n\tconst index = new Set();\n\tlet idx = 0;\n\n\tfor (let i=0; i<array.length; i++) {\n\t\tif (!index.has(array[i])) {\n\t\t\tindex.add(array[i]);\n\t\t\tresult[idx] = array[i];\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn result.slice(0, idx);\n}\n\n\n/**\n * Faster Array.prototype.map\n *\n * @ignore\n */\nexport function fastMap(array, fun) {\n\tconst result = new Array(array.length);\n\tfor (let i=0; i<array.length; i++) {\n\t\tresult[i] = fun(array[i]);\n\t}\n\treturn result;\n}\n\n\n/**\n * Flatten nested array\n *\n * @ignore\n */\nexport function flatten(array) {\n\tlet length = 0;\n\tfor (let i=0; i<array.length; i++) {\n\t\tlength += array[i].length;\n\t}\n\n\tconst result = new Array(length);\n\tlet idx = 0;\n\tfor (let i=0; i<array.length; i++) {\n\t\tfor (let j=0; j<array[i].length; j++) {\n\t\t\tresult[idx] = array[i][j];\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn result;\n}\n","/**\n * NoSuchColumnError means specified no indexed column.\n */\nexport class NoSuchColumnError extends Error {\n\t/**\n\t * @param {object} column - name of errored column.\n\t */\n\tconstructor(column) {\n\t\tsuper(column + ': no such column or no indexed');\n\n\t\t/**\n\t\t * Column name that errored.\n\t\t *\n\t\t * @type {object}\n\t\t */\n\t\tthis.column = column;\n\n\t\t/** @ignore */\n\t\tthis.name = '';\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, NoSuchColumnError);\n\t\t}\n\t}\n}\n\n\n/**\n * InvalidKeyError means specified invalid key.\n */\nexport class InvalidKeyError extends Error {\n\t/**\n\t * @param {object} key - name of specified key.\n\t */\n\tconstructor(key) {\n\t\tsuper('invalid key');\n\n\t\t/**\n\t\t * Key name that specified.\n\t\t *\n\t\t * @type {object}\n\t\t */\n\t\tthis.key = key;\n\n\t\t/** @ignore */\n\t\tthis.name = '';\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, InvalidKeyError);\n\t\t}\n\t}\n}\n","import {splitQuery, splitWords} from './utils';\nimport {NoSuchColumnError} from './errors';\n\n\n/**\n * Promise like object for contents array.\n *\n * Almost methods are the same interface as {@link IndexedFTS} and {@link IFTSTransaction}.\n * But this class will processing all contents without using indexes.\n * Please consider using {@link IFTSTransaction} directly if it can.\n */\nexport default class IFTSArrayPromise {\n\t/**\n\t * @param {Set<string>} indexes - index names.\n\t * @param {Promise<object[]>} promise - Promise for wrapping.\n\t */\n\tconstructor(indexes, promise) {\n\t\t/** @type {Set<string>} */\n\t\tthis.indexes = indexes;\n\n\t\t/** @type {Promise<object[]>} */\n\t\tthis.promise = promise;\n\t}\n\n\t/**\n\t * Make resolved promise.\n\t *\n\t * @param {Set<string>} indexes - index names.\n\t * @param {object[]} value - value for promise.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tstatic resolve(indexes, value=[]) {\n\t\treturn new IFTSArrayPromise(indexes, Promise.resolve(value));\n\t}\n\n\t/**\n\t * Make rejected promise.\n\t *\n\t * @param {Set<string>} indexes - index names.\n\t * @param {object} value - value for promise.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tstatic reject(indexes, value=null) {\n\t\treturn new IFTSArrayPromise(indexes, Promise.reject(value));\n\t}\n\n\t/**\n\t * Set next function.\n\t *\n\t * @param {function(contents: object[]): *} fun - next function.\n\t *\n\t * @return {Promise}\n\t */\n\tthen(fun) {\n\t\treturn this.promise.then(fun);\n\t}\n\n\t/**\n\t * Set error handling function.\n\t *\n\t * @param {function(error: *): *} fun - error handling function.\n\t *\n\t * @return {Promise}\n\t */\n\tcatch(fun) {\n\t\treturn this.promise.catch(fun);\n\t}\n\n\t/**\n\t * Do something process for each elements and make a new IFTSArrayPromise.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for processing element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tmap(fun) {\n\t\treturn new IFTSArrayPromise(this.indexes, this.then(xs => xs.map(fun)));\n\t}\n\n\t/**\n\t * Filtering elements by function and make a new IFTSArrayPromise.\n\t *\n\t * @param {function(content: object, index: Number): boolean} fun - function for filtering element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tfilter(fun) {\n\t\treturn new IFTSArrayPromise(this.indexes, this.then(xs => xs.filter(fun)));\n\t}\n\n\t/**\n\t * Sort contents.\n\t *\n\t * @param {object} column - the column for sorting.\n\t * @param {'asc'|'desc'} [order='asc'] - sort order.\n\t * @param {Number} [offset=0] - starting offset of the result.\n\t * @param {Number} [limit] - maximum number of result length. will unlimited if omitted.\n\t *\n\t * @return {IFTSArrayPromise} sorted contents.\n\t */\n\tsort(column, order='asc', offset=0, limit=undefined) {\n\t\tif (!this.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\treturn new IFTSArrayPromise(this.indexes, this.then(xs => Array.prototype.concat.call([], xs).sort((x, y) => {\n\t\t\tif (x[column] < y[column]) {\n\t\t\t\treturn order === 'desc' ? 1 : -1;\n\t\t\t} else if (x[column] > y[column]) {\n\t\t\t\treturn order === 'desc' ? -1 : 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}).slice(offset, limit === undefined ? undefined : offset + limit)));\n\t}\n\n\t/**\n\t * Checking index of column are exists and do {@link IFTSArrayPromise#filter}.\n\t *\n\t * @ignore\n\t */\n\t_checkAndFilter(column, fun) {\n\t\tif (!this.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\treturn this.filter(fun);\n\t}\n\n\t/**\n\t * Get contents that have fully matched property.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tequals(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] === value);\n\t}\n\n\t/**\n\t * Get contents that have property lower than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlower(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] < value);\n\t}\n\n\t/**\n\t * Get contents that have property greater than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreater(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] > value);\n\t}\n\n\t/**\n\t * Get contents that have property lower than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlowerOrEquals(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] <= value);\n\t}\n\n\t/**\n\t * Get contents that have property greater than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreaterOrEquals(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] >= value);\n\t}\n\n\t/**\n\t * Get contents that have property is between argument values.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} lower - minimal value.\n\t * @param {object} upper - maximum value.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tbetween(column, lower, upper) {\n\t\treturn this._checkAndFilter(column, x => lower <= x[column] && x[column] <= upper);\n\t}\n\n\t/**\n\t * Get contents that have matched property by full-text search.\n\t *\n\t * This method can search even if didn't made ngram index.\n\t *\n\t * WARNING: This method always processes all contents without using indexes.\n\t * Please consider using {@link IFTSTransaction#search}.\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents.\n\t */\n\tsearch(columns, query) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let c of columns) {\n\t\t\tif (!this.indexes.has(c)) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(c));\n\t\t\t}\n\t\t}\n\n\t\tconst queries = [];\n\t\tfor (let q in splitQuery(query)) {\n\t\t\tqueries.push(q);\n\t\t}\n\n\t\treturn this.filter(data => queries.every(q => columns.some(col => data[col].includes(q))));\n\t}\n\n\t/**\n\t * Find contents that have fully matched word in property.\n\t *\n\t * This method can search even if didn't made word index.\n\t *\n\t * WARNING: This method always processes all contents without using indexes.\n\t * Please consider using {@link IFTSTransaction#searchWord}.\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearchWord(columns, query) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let c of columns) {\n\t\t\tif (!this.indexes.has(c)) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(c));\n\t\t\t}\n\t\t}\n\n\t\tconst queries = splitWords(query);\n\n\t\treturn this.filter(data => queries.every(q => columns.some(col => {\n\t\t\treturn splitWords(data[col]).includes(q);\n\t\t})));\n\t}\n}\n","import {tokenize, splitQuery, splitWords, fastMap, flatten, dedup} from './utils';\nimport {NoSuchColumnError, InvalidKeyError} from './errors';\nimport IFTSArrayPromise from './IFTSArrayPromise';\n\n\n/**\n * Transaction.\n *\n * Almost methods are the same interface as {@link IndexedFTS} and {@link IFTSArrayPromise}.\n * Probably this class is faster than other classes in most cases.\n *\n * Please be careful, IFTSTransaction are sometimes makes a big cache.\n * Should not keep many transactions if not need.\n */\nexport default class IFTSTransaction {\n\t/**\n\t * @param {IndexedFTS} db - database.\n\t * @param {IDBTransaction} transaction - transaction of IndexedDB.\n\t */\n\tconstructor(db, transaction) {\n\t\t/** @type {IndexedDB} */\n\t\tthis.db = db;\n\n\t\t/** @type {IDBTransaction} */\n\t\tthis.transaction = transaction;\n\n\t\t/** @ignore */\n\t\tthis._KeyRange = this.db.scope.IDBKeyRange;\n\n\t\t/**\n\t\t * Promise for await closing transaction.\n\t\t *\n\t\t * @type {Promise<IndexedDB>}\n\t\t */\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.transaction.oncomplete = () => resolve(this.db);\n\t\t\tthis.transaction.onerror = err => reject(err);\n\t\t});\n\n\t\t/** @ignore */\n\t\tthis._cache = {};\n\t}\n\n\t/**\n\t * Put contents into database.\n\t *\n\t * @param {object} contents - contents for save. allowed multiple arguments.\n\t *\n\t * @return {Promise<IFTSTransaction>} returns self for chain.\n\t */\n\tput(...contents) {\n\t\tconst store = this.transaction.objectStore('data');\n\t\tconst ngram_indexes = fastMap([...this.db.ngram_indexes], column => ({name: column, store: this.transaction.objectStore(this.db.index_prefix + 'ngram_' + column)}));\n\t\tconst word_indexes = fastMap([...this.db.word_indexes], column => ({name: column, store: this.transaction.objectStore(this.db.index_prefix + 'word_' + column)}));\n\n\t\tconst putPromises = new Array(contents.length);\n\t\tfor (let i=0; i<contents.length; i++) {\n\t\t\tputPromises[i] = new Promise((resolve, reject) => {\n\t\t\t\tconst req = store.put(contents[i]);\n\t\t\t\treq.onerror = reject;\n\t\t\t\treq.onsuccess = ev => {\n\t\t\t\t\tresolve(\n\t\t\t\t\t\tthis._updateNGramIndex(ev.target.result, contents[i], ngram_indexes)\n\t\t\t\t\t\t\t.then(() => this._updateWordIndex(ev.target.result, contents[i], word_indexes)))\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\treturn Promise.all(putPromises).then(data => {\n\t\t\tfor (let i=0; i<data.length; i++) {\n\t\t\t\tconst key = data[i][0];\n\t\t\t\tconst value = data[i][1];\n\t\t\t\tif (this.db.primary_key === null) {\n\t\t\t\t\tvalue._key = key;\n\t\t\t\t}\n\t\t\t\tthis._cache[key] = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t});\n\t}\n\n\t/**\n\t * Update ngram index.\n\t *\n\t * @ignore\n\t */\n\t_updateNGramIndex(key, data, ngram_indexes) {\n\t\treturn this._deleteIndex(key, ngram_indexes.map(x => this.db.index_prefix + 'ngram_' + x.name))\n\t\t\t.then(() => Promise.all(fastMap(ngram_indexes, col => {\n\t\t\t\tconst tokens = tokenize(data[col.name]);\n\t\t\t\tconst promises = new Array(tokens.length);\n\t\t\t\tfor (let i=0; i<tokens.length; i++) {\n\t\t\t\t\tpromises[i] = new Promise((resolve, reject) => {\n\t\t\t\t\t\tconst req = col.store.put({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\ttoken: tokens[i],\n\t\t\t\t\t\t});\n\t\t\t\t\t\treq.onsuccess = () => resolve();\n\t\t\t\t\t\treq.onerror = reject;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn Promise.all(promises);\n\t\t\t})))\n\t\t\t.then(() => [key, data]);\n\t}\n\n\t/**\n\t * Update word index.\n\t *\n\t * @ignore\n\t */\n\t_updateWordIndex(key, data, word_indexes) {\n\t\treturn this._deleteIndex(key, word_indexes.map(x => this.db.index_prefix + 'word_' + x.name))\n\t\t\t.then(() => Promise.all(fastMap(word_indexes, col => {\n\t\t\t\tconst words = splitWords(data[col.name]);\n\t\t\t\tconst promises = new Array(words.length);\n\t\t\t\tfor (let i=0; i<words.length; i++) {\n\t\t\t\t\tpromises[i] = new Promise((resolve, reject) => {\n\t\t\t\t\t\tconst req = col.store.put({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tword: words[i],\n\t\t\t\t\t\t});\n\t\t\t\t\t\treq.onsuccess = () => resolve();\n\t\t\t\t\t\treq.onerror = reject;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn Promise.all(promises);\n\t\t\t})))\n\t\t\t.then(() => [key, data]);\n\t}\n\n\t/**\n\t * Delete content by FTS indexes of database.\n\t *\n\t * @ignore\n\t */\n\t_deleteIndex(key, tableNames) {\n\t\treturn Promise.all(tableNames.map(table => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst store = this.transaction.objectStore(table);\n\t\t\t\tstore.onerror = reject;\n\n\t\t\t\tconst requests = [];\n\n\t\t\t\tconst req = store.index('key').openKeyCursor(this._KeyRange.only(key));\n\t\t\t\treq.onerror = reject;\n\t\t\t\treq.onsuccess = ev => {\n\t\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\trequests.push(new Promise((resolve, reject) => {\n\t\t\t\t\t\t\tconst d = store.delete(cursor.primaryKey);\n\t\t\t\t\t\t\td.onsuccess = resolve;\n\t\t\t\t\t\t\td.onerror = reject\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(Promise.all(requests));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\t}\n\n\t/**\n\t * Delete contents from database.\n\t *\n\t * @param {object} keys - key of contents. allowed multiple arguments.\n\t *\n\t * @return {Promise<IFTSTransaction>} returns self for chain. Will reject with {@link InvalidKeyError} if keys included null or undefined.\n\t */\n\tdelete(...keys) {\n\t\tfor (let i=0; i<keys.length; i++) {\n\t\t\tif (keys[i] === null || keys[i] === undefined) {\n\t\t\t\treturn Promise.reject(new InvalidKeyError(keys[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all(fastMap(keys, key => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst req = this.transaction.objectStore('data').delete(key);\n\t\t\t\treq.onerror = reject;\n\t\t\t\treq.onsuccess = resolve;\n\t\t\t})\n\t\t\t.then(() => this._deleteIndex(key, [\n\t\t\t\t...[...this.db.ngram_indexes].map(x => this.db.index_prefix + 'ngram_' + x),\n\t\t\t\t...[...this.db.word_indexes].map(x => this.db.index_prefix + 'word_' + x),\n\t\t\t]))\n\t\t})).then(() => this);\n\t}\n\n\t/**\n\t * Make {@link IFTSArrayPromise} by cursor.\n\t *\n\t * @ignore\n\t */\n\t_readCursor(cursorRequest, filter=null, map=null, limit=undefined) {\n\t\tfilter = filter || ((x, i) => true);\n\t\tmap = map || ((x, i) => x);\n\n\t\treturn new IFTSArrayPromise(this.db.indexes, new Promise((resolve, reject) => {\n\t\t\tconst result = [];\n\t\t\tlet index = 0;\n\n\t\t\tcursorRequest.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tconst value = cursor.value;\n\t\t\t\t\tif (this.db.primary_key === null) {\n\t\t\t\t\t\tvalue._key = cursor.key;\n\t\t\t\t\t}\n\t\t\t\t\tthis._cache[cursor.key] = value;\n\t\t\t\t\tif (filter(value, index)) {\n\t\t\t\t\t\tresult.push(map(value, index));\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (limit === undefined || index < limit) {\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcursorRequest.onerror = err => reject(err);\n\t\t}));\n\t}\n\n\t/**\n\t * Get all contents.\n\t *\n\t * @return {IFTSArrayPromise} contents.\n\t */\n\tgetAll() {\n\t\treturn this._readCursor(this.transaction.objectStore('data').openCursor());\n\t}\n\n\t/**\n\t * Get all contents with primary keys.\n\t *\n\t * @ignore\n\t */\n\t_getAllWithKeys() {\n\t\treturn new IFTSArrayPromise(this.db.indexes, new Promise((resolve, reject) => {\n\t\t\tconst request = this.transaction.objectStore('data').openCursor();\n\n\t\t\tconst result = [];\n\t\t\trequest.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tconst value = cursor.value;\n\t\t\t\t\tif (this.db.primary_key === null) {\n\t\t\t\t\t\tvalue._key = cursor.key;\n\t\t\t\t\t}\n\t\t\t\t\tthis._cache[cursor.key] = value;\n\t\t\t\t\tresult.push({key: cursor.key, data: value});\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\trequest.onerror = err => reject(err);\n\t\t}));\n\t}\n\n\t/**\n\t * Do something process for each elements and returns {@link IFTSArrayPromise}.\n\t *\n\t * NOTE: This method doesn't fast. May better do filtering before doing map if need filtering.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for processing element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tmap(fun) {\n\t\treturn this._readCursor(this.transaction.objectStore('data').openCursor(null), null, fun);\n\t}\n\n\t/**\n\t * Filtering elements by function and returns {@link IFTSArrayPromise}.\n\t *\n\t * WARNING: This method won't use the index. Other methods(eg. {@link IFTSTransaction#equals} or {@link IFTSTransaction#lower} may faster than this.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for filtering element.\n\t *\n\t * return {IFTSArrayPromise}\n\t */\n\tfilter(fun) {\n\t\treturn this._readCursor(this.transaction.objectStore('data').openCursor(null), fun, null);\n\t}\n\n\t/**\n\t * Sort and get all contents.\n\t *\n\t * @param {object} column - the column for sorting.\n\t * @param {'asc'|'desc'} [order='asc'] - sort order.\n\t * @param {Number} [offset=0] - starting offset of the result.\n\t * @param {Number} [limit] - maximum number of result length. will unlimited if omitted.\n\t *\n\t * @return {IFTSArrayPromise} sorted contents.\n\t */\n\tsort(column, order='asc', offset=0, limit=undefined) {\n\t\tif (!this.db.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.db.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\tlimit = limit === undefined ? undefined : offset + limit;\n\t\tconst offsetFilter = (x, i) => offset <= i;\n\n\t\tconst store = this.transaction.objectStore('data');\n\n\t\tif (column === this.db.primary_key) {\n\t\t\treturn this._readCursor(store.openCursor(null, order === 'desc' ? 'prev' : 'next'), offsetFilter, null, limit);\n\t\t} else {\n\t\t\treturn this._readCursor(store.index(column).openCursor(null, order === 'desc' ? 'prev' : 'next'), offsetFilter, null, limit);\n\t\t}\n\t}\n\n\t/**\n\t * Get content by primary key.\n\t *\n\t * @param {object} key - the key of content.\n\t *\n\t * @return {Promise<object|undefined>} content. promise will reject with {@link InvalidKeyError} if keys included null or undefined. result value will be undefined if not found.\n\t */\n\tget(key) {\n\t\tif (key === null || key === undefined) {\n\t\t\treturn Promise.reject(new InvalidKeyError(key));\n\t\t}\n\t\tif (key in this._cache) {\n\t\t\treturn Promise.resolve(this._cache[key]);\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst req = this.transaction.objectStore('data').get(key);\n\t\t\treq.onsuccess = ev => {\n\t\t\t\tconst value = ev.target.result;\n\t\t\t\tif (this.db.primary_key === null) {\n\t\t\t\t\tvalue._key = key;\n\t\t\t\t}\n\t\t\t\tthis._cache[key] = value;\n\t\t\t\tresolve(value);\n\t\t\t};\n\t\t\treq.onerror = reject;\n\t\t});\n\t}\n\n\t/**\n\t * Get contents matched keyRange.\n\t *\n\t * @ignore\n\t */\n\t_getAllWithIndex(column, keyRange) {\n\t\tif (!this.db.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.db.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\tconst store = this.transaction.objectStore('data');\n\n\t\tif (column === this.db.primary_key) {\n\t\t\treturn this._readCursor(store.openCursor(keyRange));\n\t\t} else {\n\t\t\treturn this._readCursor(store.index(column).openCursor(keyRange));\n\t\t}\n\t}\n\n\t/**\n\t * Get contents that have fully matched property.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tequals(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.only(value));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlower(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.upperBound(value, true));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreater(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.lowerBound(value, true));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlowerOrEquals(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.upperBound(value, false));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreaterOrEquals(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.lowerBound(value, false));\n\t}\n\n\t/**\n\t * Get contents that have property is between argument values.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} lower - minimal value.\n\t * @param {object} upper - maximum value.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tbetween(column, lower, upper) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.bound(lower, upper, false, false));\n\t}\n\n\t/**\n\t * Get candidates of search result.\n\t *\n\t * @ignore\n\t */\n\t_takeCandidatesBySingleColumn(column, queries) {\n\t\tconst index = this.transaction.objectStore(this.db.index_prefix + 'ngram_' + column).index('token');\n\t\tconst result = [];\n\n\t\tfor (let q in queries) {\n\t\t\tif (queries[q].length === 0) {\n\t\t\t\tresult.push(this._getAllWithKeys().filter(x => x.data[column].includes(q)).map(x => x.key).then(xs => ({query: q, keys: xs})));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst promises = new Array(queries[q].length);\n\t\t\tfor (let i=0; i<queries[q].length; i++) {\n\t\t\t\tpromises[i] = this._readCursor(index.openCursor(queries[q][i]), null, data => data.key);\n\t\t\t}\n\n\t\t\tconst candidate = Promise.all(promises)\n\t\t\t\t.then(founds => {\n\t\t\t\t\tif (founds.length === 0) {\n\t\t\t\t\t\treturn Promise.resolve([]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfounds = flatten(founds);\n\n\t\t\t\t\tconst deduped = new Array(founds.length);\n\t\t\t\t\tlet dedup_num = 0;\n\t\t\t\t\tconst hit_count = {};\n\t\t\t\t\tfor (let i=0; i<founds.length; i++) {\n\t\t\t\t\t\tif (!(founds[i] in hit_count)) {\n\t\t\t\t\t\t\thit_count[founds[i]] = 0;\n\n\t\t\t\t\t\t\tdeduped[dedup_num] = founds[i];\n\t\t\t\t\t\t\tdedup_num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thit_count[founds[i]]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst candidates = new Array(dedup_num);\n\t\t\t\t\tlet candidate_num = 0;\n\t\t\t\t\tfor (let i=0; i<dedup_num; i++) {\n\t\t\t\t\t\tif (hit_count[deduped[i]] >= queries[q].length) {\n\t\t\t\t\t\t\tcandidates[candidate_num] = this.get(deduped[i]).then(data => ({key: deduped[i], data: data}));\n\t\t\t\t\t\t\tcandidate_num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Promise.all(candidates.slice(0, candidate_num));\n\t\t\t\t})\n\t\t\t\t.then(xs => ({query: q, keys: xs.filter(x => x.data[column].includes(q)).map(x => x.key)}))\n\n\t\t\tresult.push(candidate);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Prune contents by result of {@link IFTSTransaction#_takeCandidatesBySingleColumn}.\n\t *\n\t * @ignore\n\t */\n\tasync _pruneCandidates(queries_num, candidates) {\n\t\tconst keys = {};\n\n\t\tfor (let i=0; i<candidates.length; i++) {\n\t\t\tfor (let j=0; j<candidates[i].keys.length; j++) {\n\t\t\t\tif (!(candidates[i].keys[j] in keys)) {\n\t\t\t\t\tkeys[candidates[i].keys[j]] = new Set();\n\t\t\t\t}\n\t\t\t\tkeys[candidates[i].keys[j]].add(candidates[i].query);\n\t\t\t}\n\t\t}\n\n\t\tconst result = new Array(candidates.length);\n\t\tlet result_num = 0;\n\t\tfor (let key in keys) {\n\t\t\tif (keys[key].size == queries_num) {\n\t\t\t\tresult[result_num] = this.get(key);\n\t\t\t\tresult_num++;\n\t\t\t}\n\t\t}\n\n\t\treturn await Promise.all(result.slice(0, result_num));\n\t}\n\n\t/**\n\t * Get contents that have matched property by full-text search.\n\t *\n\t * All target columns have to made ngram index when created database.\n\t * If you didn't made ngram index, you can use {@link IFTSArrayPromise#search} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearch(columns, query) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let i=0; i<columns.length; i++) {\n\t\t\tif (!this.db.ngram_indexes.has(columns[i])) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.db.indexes, new NoSuchColumnError(columns[i]));\n\t\t\t}\n\t\t}\n\n\t\tconst queries = splitQuery(query);\n\t\tlet queries_length = 0;\n\n\t\tfor (let q in queries) {\n\t\t\tqueries[q] = fastMap(queries[q], x => this._KeyRange.only(x));\n\t\t\tqueries_length++;\n\t\t}\n\n\t\tconst candidatePromises = [];\n\n\t\tfor (let i=0; i<columns.length; i++) {\n\t\t\tArray.prototype.push.apply(candidatePromises, this._takeCandidatesBySingleColumn(columns[i], queries));\n\t\t}\n\n\t\treturn new IFTSArrayPromise(\n\t\t\tthis.db.indexes,\n\t\t\tPromise.all(candidatePromises).then(xs => this._pruneCandidates(queries_length, xs)),\n\t\t);\n\t}\n\n\t/**\n\t * Find contents that have fully matched word in property.\n\t *\n\t * All target columns have to made word index when created database.\n\t * If you didn't made word index, you can use {@link IFTSArrayPromise#searchWord} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearchWord(columns, query) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let i=0; i<columns.length; i++) {\n\t\t\tif (!this.db.word_indexes.has(columns[i])) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.db.indexes, new NoSuchColumnError(columns[i]));\n\t\t\t}\n\t\t}\n\n\t\tconst queries = splitWords(query).map(x => ({text: x, keyRange: this._KeyRange.only(x)}));\n\n\t\treturn new IFTSArrayPromise(this.db.indexes, Promise.all(flatten(columns.map(col => {\n\t\t\tconst index = this.transaction.objectStore(this.db.index_prefix + 'word_' + col).index('word');\n\n\t\t\treturn queries.map(query => this._readCursor(index.openCursor(query.keyRange), null, data => [data.key, query.text]));\n\t\t}))).then(candidates => {\n\t\t\tcandidates = dedup(flatten(candidates));\n\n\t\t\tconst counts = {};\n\t\t\tfor (let i=0; i<candidates.length; i++) {\n\t\t\t\tconst key = candidates[i][0];\n\t\t\t\tif (!(key in counts)) {\n\t\t\t\t\tcounts[key] = 0;\n\t\t\t\t}\n\t\t\t\tcounts[key]++;\n\t\t\t}\n\n\t\t\tconst hits = new Array(candidates.length);\n\t\t\tlet hits_count = 0;\n\t\t\tfor (let i=0; i<candidates.length; i++) {\n\t\t\t\tconst key = candidates[i][0];\n\t\t\t\tif (counts[key] >= queries.length) {\n\t\t\t\t\thits[hits_count] = key;\n\t\t\t\t\thits_count++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = new Array(hits_count);\n\t\t\tfor (let i=0; i<hits_count; i++) {\n\t\t\t\tresult[i] = this.get(hits[i]);\n\t\t\t}\n\t\t\treturn new IFTSArrayPromise(this.db.indexes, Promise.all(result));\n\t\t}));\n\t}\n\n\t/**\n\t * Get N-Gram set from index.\n\t *\n\t * @param {string} column - name of column.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetNGrams(column) {\n\t\tif (!this.db.ngram_indexes.has(column)) {\n\t\t\treturn Promise.reject(new NoSuchColumnError(column));\n\t\t}\n\n\t\tconst result = new Map();\n\n\t\tconst cursor = this.transaction.objectStore(this.db.index_prefix + 'ngram_' + column).openCursor();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tcursor.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tresult.set(cursor.value.token, (result.get(cursor.value.token) || 0) + 1);\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcursor.onerror = ev => reject(ev);\n\t\t});\n\t}\n\n\t/**\n\t * Get word set from index.\n\t *\n\t * @param {string} column - name of column.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetWords(column) {\n\t\tif (!this.db.word_indexes.has(column)) {\n\t\t\treturn Promise.reject(new NoSuchColumnError(column));\n\t\t}\n\n\t\tconst result = new Map();\n\n\t\tconst cursor = this.transaction.objectStore(this.db.index_prefix + 'word_' + column).openCursor();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tcursor.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tresult.set(cursor.value.word, (result.get(cursor.value.word) || 0) + 1);\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcursor.onerror = ev => reject(ev);\n\t\t});\n\t}\n}\n","import IFTSTransaction from './IFTSTransaction';\n\n\n/**\n * The database of IndexedFTS.\n *\n * Almost methods are the same interface as {@link IDBTransaction} and {@link IFTSArrayPromise}.\n */\nexport default class IndexedFTS {\n\t/**\n\t * Create or open IndexedFTS.\n\t *\n\t * Database has name and schema's version.\n\t * The name is a name of the database in the storage.\n\t *\n\t * The schema is an object that key is column name and value is a definition of indexes. Schema can't change in same version database.\n\t * If you want change schema of database, please change version number.\n\t * Please be careful, all contents will remove when changing the version number.\n\t *\n\t * Index types are 'primary', 'unique', 'fulltext', 'ngram', 'word', or normal index.\n\t *\n\t * 'primary' is a primary key of the database. 'primary' can't set to multiple columns.\n\t *\n\t * 'unique' is columns that have a unique value in the database.\n\t *\n\t * If set 'ngram' IndexedFTS will make 2-gram index table for full-text search.\n\t * 'fulltext' is alias to 'ngram'.\n\t *\n\t * 'word' is word based index.\n\t * The word index will split text with whitespaces and store those.\n\t * Word index is faster than the 'ngram' index but can't find a partial match in the word.\n\t *\n\t * The normal index that not set optioned that not unique, not primary, and not indexed for full-text search. You can numeric search like {@link IndexedFTS#lower} {@link IndexedFTS#between} even if not set option.\n\t *\n\t * If you want to set some index types, please use object like `{unique: true, fulltext: true}`.\n\t *\n\t * @param {string} name - name of new (or open) database.\n\t * @param {number} version - schema's version of database.\n\t * @param {Array<string|object>} schema - database schema.\n\t * @param {object} [options] - other options.\n\t * @param {string} [options.index_prefix='indexedfts_'] - prefix of indexes for full-text search.\n\t * @param {object} [options.scope=window] - endpoints for IndexedDB API.\n\t */\n\tconstructor(name, version, schema, options={}) {\n\t\t/** @type {string} */\n\t\tthis.index_prefix = options.index_prefix || 'indexedfts_';\n\n\t\t/** @type {object} */\n\t\tthis.scope = options.scope || window;\n\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\n\t\t/** @type {number} */\n\t\tthis.version = version;\n\n\t\t/** @type {object} */\n\t\tthis.schema = schema;\n\n\t\t/** @type {object} */\n\t\tthis.store_option = {autoIncrement: true};\n\n\t\t/** @type {string|null} */\n\t\tthis.primary_key = null;\n\n\t\t/** @type {Set<string>} */\n\t\tthis.ngram_indexes = new Set();\n\n\t\t/** @type {Set<string>} */\n\t\tthis.word_indexes = new Set();\n\n\t\t/** @type {Set<string>} */\n\t\tthis.unique_indexes = new Set();\n\n\t\t/** @type {Set<string>} */\n\t\tthis.normal_indexes = new Set();\n\n\t\t/** @type {IDBDatabase} */\n\t\tthis.db = null;\n\n\t\tfor (let x in schema) {\n\t\t\tif (schema[x] === 'primary' || schema[x].primary) {\n\t\t\t\tif ('keyPath' in this.store_option) {\n\t\t\t\t\tthrow new Error('can not use multi primary key');\n\t\t\t\t}\n\t\t\t\tthis.primary_key = x;\n\t\t\t\tthis.store_option = {keyPath: x};\n\t\t\t} else if (schema[x] === 'unique' || schema[x].unique) {\n\t\t\t\tthis.unique_indexes.add(x);\n\t\t\t} else {\n\t\t\t\tthis.normal_indexes.add(x);\n\t\t\t}\n\n\t\t\tif (schema[x] === 'ngram' || schema[x].ngram\n\t\t\t|| schema[x] === 'fulltext' || schema[x].fulltext) {\n\t\t\t\tthis.ngram_indexes.add(x);\n\t\t\t}\n\n\t\t\tif (schema[x] === 'word' || schema[x].word) {\n\t\t\t\tthis.word_indexes.add(x);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Delete database.\n\t *\n\t * Must be close all IndexedFTS before delete database.\n\t *\n\t * @param {string} name - name of target database. this method will success even if no such database.\n\t * @param {object} [scope] - endpoints for IndexedDB API.\n\t *\n\t * @return {Promise<undefined>}\n\t */\n\tstatic delete(name, scope=null) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst req = (scope || window).indexedDB.deleteDatabase(name);\n\t\t\treq.onsuccess = ev => resolve();\n\t\t\treq.onerror = ev => reject(ev);\n\t\t});\n\t}\n\n\t/** @type {Set<string>} */\n\tget indexes() {\n\t\tconst r = new Set([...this.ngram_indexes, ...this.word_indexes, ...this.unique_indexes, ...this.normal_indexes]);\n\t\tif (this.primary_key !== null) {\n\t\t\tr.add(this.primary_key);\n\t\t}\n\t\treturn r;\n\t}\n\n\t/**\n\t * Open database.\n\t *\n\t * @return {Promise<undefined>}\n\t */\n\topen() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = this.scope.indexedDB.open(this.name, this.version);\n\n\t\t\trequest.onsuccess = ev => {\n\t\t\t\tthis.db = ev.target.result;\n\t\t\t\tresolve(this);\n\t\t\t};\n\t\t\trequest.onerror = reject;\n\n\t\t\trequest.onupgradeneeded = ev => {\n\t\t\t\tthis.db = ev.target.result;\n\n\t\t\t\tconst store = this.db.createObjectStore('data', this.store_option);\n\n\t\t\t\tstore.onerror = reject;\n\n\t\t\t\tthis.unique_indexes.forEach(x => store.createIndex(x, x, {unique: true}));\n\n\t\t\t\tthis.normal_indexes.forEach(x => store.createIndex(x, x, {unique: false}));\n\n\t\t\t\tthis.ngram_indexes.forEach(column => {\n\t\t\t\t\tconst fts_store = this.db.createObjectStore(this.index_prefix + 'ngram_' + column, {autoIncrement: true});\n\t\t\t\t\tfts_store.onerror = reject\n\t\t\t\t\tfts_store.createIndex('key', 'key', {unique: false});\n\t\t\t\t\tfts_store.createIndex('token', 'token', {unique: false});\n\t\t\t\t});\n\n\t\t\t\tthis.word_indexes.forEach(column => {\n\t\t\t\t\tconst fts_store = this.db.createObjectStore(this.index_prefix + 'word_' + column, {autoIncrement: true});\n\t\t\t\t\tfts_store.onerror = reject\n\t\t\t\t\tfts_store.createIndex('key', 'key', {unique: false});\n\t\t\t\t\tfts_store.createIndex('word', 'word', {unique: false});\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Close database.\n\t */\n\tclose() {\n\t\tthis.db.close();\n\t}\n\n\t/**\n\t * Make new {@link IFTSTransaction}.\n\t *\n\t * @param {\"readonly\"|\"readwrite\"} mode - mode of transaction.\n\t * @param {string[]|null} target - open index targets. open for all if null.\n\t *\n\t * @return {IFTSTransaction}\n\t */\n\ttransaction(mode='readonly', target=null) {\n\t\tif (target === null) {\n\t\t\tconst ngrams = [...this.ngram_indexes].map(x => this.index_prefix + 'ngram_' + x);\n\t\t\tconst words = [...this.word_indexes].map(x => this.index_prefix + 'word_' + x);\n\t\t\ttarget = ngrams.concat(words).concat(['data']);\n\t\t}\n\t\treturn new IFTSTransaction(this, this.db.transaction(target, mode));\n\t}\n\n\t/**\n\t * Put contents into database.\n\t *\n\t * @param {object} contents - contents for save. allowed multiple arguments.\n\t *\n\t * @return {Promise<IndexedFTS>} returns self for chain.\n\t */\n\tput(...contents) {\n\t\treturn this.transaction('readwrite').put(...contents).then(() => this);\n\t}\n\n\t/**\n\t * Delete contents from database.\n\t *\n\t * @param {object} keys - key of contents.\n\t *\n\t * @return {Promise<IndexedFTS>} returns self for chain. Will reject with {@link InvalidKeyError} if keys included null or undefined.\n\t */\n\tdelete(...keys) {\n\t\treturn this.transaction('readwrite').delete(...keys).then(() => this);\n\t}\n\n\t/**\n\t * Get content by primary key.\n\t *\n\t * @param {object} key - the key of content.\n\t *\n\t * @return {Promise<object|undefined>} content. promise will reject with {@link InvalidKeyError} if keys included null or undefined. result value will be undefined if not found.\n\t */\n\tget(key) {\n\t\treturn this.transaction('readonly', 'data').get(key);\n\t}\n\n\t/**\n\t * Get filtered contents.\n\t *\n\t * @ignore\n\t */\n\t_getFiltered(fun) {\n\t\treturn fun(this.transaction('readonly', 'data'));\n\t}\n\n\t/**\n\t * Get all contents.\n\t *\n\t * @return {IFTSArrayPromise} contents.\n\t */\n\tgetAll() {\n\t\treturn this._getFiltered(x => x.getAll());\n\t}\n\n\t/**\n\t * Do something process for each elements and returns {@link IFTSArrayPromise}.\n\t *\n\t * NOTE: This method doesn't fast. May better do filtering before doing map if need filtering.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for processing element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tmap(fun) {\n\t\treturn this._getFiltered(x => x.map(fun));\n\t}\n\n\t/**\n\t * Filtering elements by function and returns {@link IFTSArrayPromise}.\n\t *\n\t * WARNING: This method won't use the index. Other methods(eg. {@link IFTSTransaction#equals or @link IFTSTransaction#lower} may faster than this.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for filtering element.\n\t *\n\t * return {IFTSArrayPromise}\n\t */\n\tfilter(fun) {\n\t\treturn this._getFiltered(x => x.filter(fun));\n\t}\n\n\t/**\n\t * Sort and get all contents.\n\t *\n\t * @param {object} column - the column for sorting.\n\t * @param {'asc'|'desc'} [order='asc'] - sort order.\n\t * @param {Number} [offset=0] - starting offset of the result.\n\t * @param {Number} [limit] - maximum number of result length. will unlimited if omitted.\n\t *\n\t * @return {IFTSArrayPromise} sorted contents.\n\t */\n\tsort(column, order='asc', offset=0, limit=undefined) {\n\t\treturn this._getFiltered(x => x.sort(column, order, offset, limit));\n\t}\n\n\t/**\n\t * Get contents that have fully matched property.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tequals(column, value) {\n\t\treturn this._getFiltered(x => x.equals(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlower(column, value) {\n\t\treturn this._getFiltered(x => x.lower(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreater(column, value) {\n\t\treturn this._getFiltered(x => x.greater(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlowerOrEquals(column, value) {\n\t\treturn this._getFiltered(x => x.lowerOrEquals(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreaterOrEquals(column, value) {\n\t\treturn this._getFiltered(x => x.greaterOrEquals(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property is between argument values.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} lower - minimal value.\n\t * @param {object} upper - maximum value.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tbetween(column, lower, upper) {\n\t\treturn this._getFiltered(x => x.between(column, lower, upper));\n\t}\n\n\t/**\n\t * Get contents that have matched property by full-text search.\n\t *\n\t * All target columns have to made ngram index when created database.\n\t * If you didn't made ngram index, you can use {@link IFTSArrayPromise#search} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearch(columns, query) {\n\t\treturn this.transaction().search(columns, query);\n\t}\n\n\t/**\n\t * Find contents that have fully matched word in property.\n\t *\n\t * All target columns have to made word index when created database.\n\t * If you didn't made word index, you can use {@link IFTSArrayPromise#searchWord} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearchWord(columns, query) {\n\t\treturn this.transaction().searchWord(columns, query);\n\t}\n\n\t/**\n\t * Get N-Gram set from index.\n\t *\n\t * @param {string} column - name of column.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetNGrams(column) {\n\t\treturn this.transaction().getNGrams(column);\n\t}\n\n\t/**\n\t * Get word set from index.\n\t *\n\t * @param {string} column - name of column.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetWords(column) {\n\t\treturn this.transaction().getWords(column);\n\t}\n}\n"],"names":["splitWords","text","dedup","split","filter","x","length","tokenize","ngram","result","i","push","slice","splitText","splitQuery","query","q","forEach","array","Array","index","Set","idx","has","add","fastMap","fun","flatten","j","NoSuchColumnError","Error","column","name","captureStackTrace","this","InvalidKeyError","key","IFTSArrayPromise","indexes","promise","value","Promise","resolve","reject","then","catch","xs","map","order","offset","limit","prototype","concat","call","sort","y","undefined","_checkAndFilter","lower","upper","columns","c","queries","data","every","some","col","includes","IFTSTransaction","db","transaction","_KeyRange","scope","IDBKeyRange","oncomplete","onerror","err","_cache","contents","store","objectStore","ngram_indexes","index_prefix","word_indexes","putPromises","req","put","onsuccess","ev","_updateNGramIndex","target","_updateWordIndex","all","primary_key","_key","_deleteIndex","tokens","promises","words","tableNames","table","requests","openKeyCursor","only","cursor","d","delete","primaryKey","continue","keys","cursorRequest","_readCursor","openCursor","request","offsetFilter","get","keyRange","_getAllWithIndex","upperBound","lowerBound","bound","_getAllWithKeys","candidate","founds","deduped","dedup_num","hit_count","candidates","candidate_num","queries_num","result_num","size","queries_length","candidatePromises","apply","_takeCandidatesBySingleColumn","_pruneCandidates","counts","hits","hits_count","Map","set","token","word","version","schema","options","window","store_option","autoIncrement","unique_indexes","normal_indexes","primary","keyPath","unique","fulltext","indexedDB","deleteDatabase","r","open","onupgradeneeded","createObjectStore","createIndex","fts_store","close","mode","ngrams","_getFiltered","getAll","equals","greater","lowerOrEquals","greaterOrEquals","between","search","searchWord","getNGrams","getWords"],"mappings":"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"}