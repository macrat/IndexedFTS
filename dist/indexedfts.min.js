!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).IndexedFTS={})}(this,(function(e){"use strict";function t(e){return s(e.split(/\s+/).filter(e=>e.length>0))}function r(e,t=2){return s(function(e,t=2){const r=[];for(let n=0;n<e.length-t+1;n++)r.push(e.slice(n,n+t));return r}(e,t))}function n(e,t=2){const n={};return e.split(/\s+/).filter(e=>e.length>0).forEach(e=>n[e]=r(e,t)),n}function s(e){const t=new Array(e.length),r=new Set;let n=0;for(let s=0;s<e.length;s++)r.has(e[s])||(r.add(e[s]),t[n]=e[s],n++);return t.slice(0,n)}function o(e,t){const r=new Array(e.length);for(let n=0;n<e.length;n++)r[n]=t(e[n]);return r}function i(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r].length;const r=new Array(t);let n=0;for(let t=0;t<e.length;t++)for(let s=0;s<e[t].length;s++)r[n]=e[t][s],n++;return r}class a extends Error{constructor(e){super(e+": no such column or no indexed"),this.column=e,this.name="",Error.captureStackTrace&&Error.captureStackTrace(this,a)}}class h extends Error{constructor(e){super("invalid key"),this.key=e,this.name="",Error.captureStackTrace&&Error.captureStackTrace(this,h)}}class l extends Error{constructor(e,t=null){super(e),this.column=t,this.name="InvalidSchemaError",Error.captureStackTrace&&Error.captureStackTrace(this,l)}}class c{constructor(e,t){this.indexes=e,this.promise=t}static resolve(e,t=[]){return new c(e,Promise.resolve(t))}static reject(e,t=null){return new c(e,Promise.reject(t))}then(e){return this.promise.then(e)}catch(e){return this.promise.catch(e)}map(e){return new c(this.indexes,this.then(t=>t.map(e)))}filter(e){return new c(this.indexes,this.then(t=>t.filter(e)))}sort(e,t="asc",r=0,n){return this.indexes.has(e)?new c(this.indexes,this.then(s=>Array.prototype.concat.call([],s).sort((r,n)=>r[e]<n[e]?"desc"===t?1:-1:r[e]>n[e]?"desc"===t?-1:1:0).slice(r,void 0===n?void 0:r+n))):c.reject(this.indexes,new a(e))}_checkAndFilter(e,t){return this.indexes.has(e)?this.filter(t):c.reject(this.indexes,new a(e))}equals(e,t){return this._checkAndFilter(e,r=>r[e]===t)}lower(e,t){return this._checkAndFilter(e,r=>r[e]<t)}greater(e,t){return this._checkAndFilter(e,r=>r[e]>t)}lowerOrEquals(e,t){return this._checkAndFilter(e,r=>r[e]<=t)}greaterOrEquals(e,t){return this._checkAndFilter(e,r=>r[e]>=t)}between(e,t,r){return this._checkAndFilter(e,n=>t<=n[e]&&n[e]<=r)}search(e,t,r={}){"string"==typeof e&&(e=[e]);for(let t of e)if(!this.indexes.has(t))return c.reject(this.indexes,new a(t));t=r.ignoreCase?t.toLowerCase():t;const s=[];for(let e in n(t))s.push(e);const o=r.ignoreCase?e=>e.toLowerCase():e=>e;return this.filter(t=>s.every(r=>e.some(e=>o(t[e]).includes(r))))}searchWord(e,r,n={}){"string"==typeof e&&(e=[e]);for(let t of e)if(!this.indexes.has(t))return c.reject(this.indexes,new a(t));const s=t(r=n.ignoreCase?r.toLowerCase():r),o=n.ignoreCase?e=>e.toLowerCase():e=>e;return this.filter(r=>s.every(n=>e.some(e=>t(o(r[e])).includes(n))))}}class d{constructor(e,t){this.db=e,this.transaction=t,this._KeyRange=this.db.scope.IDBKeyRange,this.promise=new Promise((e,t)=>{this.transaction.oncomplete=()=>e(this.db),this.transaction.onerror=e=>t(e)}),this._cache={}}put(...e){const t=this.transaction.objectStore("data"),r=o([...this.db.schema.ngramIndexes],e=>({name:e,store:this.transaction.objectStore(this.db.index_prefix+"ngram_"+e)})),n=o([...this.db.schema.wordIndexes],e=>({name:e,store:this.transaction.objectStore(this.db.index_prefix+"word_"+e)})),s=new Array(e.length);for(let o=0;o<e.length;o++)s[o]=new Promise((s,i)=>{const a=t.put(e[o]);a.onerror=i,a.onsuccess=t=>{s(this._updateNGramIndex(t.target.result,e[o],r).then(()=>this._updateWordIndex(t.target.result,e[o],n)))}});return Promise.all(s).then(e=>{for(let t=0;t<e.length;t++){const r=e[t][0],n=e[t][1];null===this.db.schema.primaryKey&&(n._key=r),this._cache[r]=n}return this})}_updateNGramIndex(e,t,n){return this._deleteIndex(e,n.map(e=>this.db.index_prefix+"ngram_"+e.name)).then(()=>Promise.all(o(n,n=>{const s=r(t[n.name]),o=new Array(s.length);for(let t=0;t<s.length;t++)o[t]=new Promise((r,o)=>{const i=n.store.put({key:e,token:s[t],lower:s[t].toLowerCase()});i.onsuccess=()=>r(),i.onerror=o});return Promise.all(o)}))).then(()=>[e,t])}_updateWordIndex(e,r,n){return this._deleteIndex(e,n.map(e=>this.db.index_prefix+"word_"+e.name)).then(()=>Promise.all(o(n,n=>{const s=t(r[n.name]),o=new Array(s.length);for(let t=0;t<s.length;t++)o[t]=new Promise((r,o)=>{const i=n.store.put({key:e,word:s[t],lower:s[t].toLowerCase()});i.onsuccess=()=>r(),i.onerror=o});return Promise.all(o)}))).then(()=>[e,r])}_deleteIndex(e,t){return Promise.all(t.map(t=>new Promise((r,n)=>{const s=this.transaction.objectStore(t);s.onerror=n;const o=[],i=s.index("key").openKeyCursor(this._KeyRange.only(e));i.onerror=n,i.onsuccess=e=>{const t=e.target.result;t?(o.push(new Promise((e,r)=>{const n=s.delete(t.primaryKey);n.onsuccess=e,n.onerror=r})),t.continue()):r(Promise.all(o))}})))}delete(...e){for(let t=0;t<e.length;t++)if(null===e[t]||void 0===e[t])return Promise.reject(new h(e[t]));return Promise.all(o(e,e=>new Promise((t,r)=>{const n=this.transaction.objectStore("data").delete(e);n.onerror=r,n.onsuccess=t}).then(()=>this._deleteIndex(e,[...[...this.db.schema.ngramIndexes].map(e=>this.db.index_prefix+"ngram_"+e),...[...this.db.schema.wordIndexes].map(e=>this.db.index_prefix+"word_"+e)])))).then(()=>this)}_readCursor(e,t=null,r=null,n){return t=t||((e,t)=>!0),r=r||((e,t)=>e),new c(this.db.schema.indexes,new Promise((s,o)=>{const i=[];let a=0;e.onsuccess=e=>{const o=e.target.result;if(o){const e=o.value;null===this.db.schema.primaryKey&&(e._key=o.key),this._cache[o.key]=e,t(e,a)&&i.push(r(e,a)),a++,void 0===n||a<n?o.continue():s(i)}else s(i)},e.onerror=e=>o(e)}))}getAll(){return this._readCursor(this.transaction.objectStore("data").openCursor())}_getAllWithKeys(){return new c(this.db.schema.indexes,new Promise((e,t)=>{const r=this.transaction.objectStore("data").openCursor(),n=[];r.onsuccess=t=>{const r=t.target.result;if(r){const e=r.value;null===this.db.schema.primaryKey&&(e._key=r.key),this._cache[r.key]=e,n.push({key:r.key,data:e}),r.continue()}else e(n)},r.onerror=e=>t(e)}))}map(e){return this._readCursor(this.transaction.objectStore("data").openCursor(null),null,e)}filter(e){return this._readCursor(this.transaction.objectStore("data").openCursor(null),e,null)}sort(e,t="asc",r=0,n){if(!this.db.schema.indexes.has(e))return c.reject(this.db.schema.indexes,new a(e));n=void 0===n?void 0:r+n;const s=(e,t)=>r<=t,o=this.transaction.objectStore("data");return e===this.db.schema.primaryKey?this._readCursor(o.openCursor(null,"desc"===t?"prev":"next"),s,null,n):this._readCursor(o.index(e).openCursor(null,"desc"===t?"prev":"next"),s,null,n)}get(e){return null==e?Promise.reject(new h(e)):e in this._cache?Promise.resolve(this._cache[e]):new Promise((t,r)=>{const n=this.transaction.objectStore("data").get(e);n.onsuccess=r=>{const n=r.target.result;null===this.db.schema.primaryKey&&(n._key=e),this._cache[e]=n,t(n)},n.onerror=r})}_getAllWithIndex(e,t){if(!this.db.schema.indexes.has(e))return c.reject(this.db.schema.indexes,new a(e));const r=this.transaction.objectStore("data");return e===this.db.schema.primaryKey?this._readCursor(r.openCursor(t)):this._readCursor(r.index(e).openCursor(t))}equals(e,t){return this._getAllWithIndex(e,this._KeyRange.only(t))}lower(e,t){return this._getAllWithIndex(e,this._KeyRange.upperBound(t,!0))}greater(e,t){return this._getAllWithIndex(e,this._KeyRange.lowerBound(t,!0))}lowerOrEquals(e,t){return this._getAllWithIndex(e,this._KeyRange.upperBound(t,!1))}greaterOrEquals(e,t){return this._getAllWithIndex(e,this._KeyRange.lowerBound(t,!1))}between(e,t,r){return this._getAllWithIndex(e,this._KeyRange.bound(t,r,!1,!1))}_takeCandidatesBySingleColumn(e,t,r={}){const n=this.transaction.objectStore(this.db.index_prefix+"ngram_"+e),s=r.ignoreCase?n.index("lower"):n.index("token"),o=[];for(let n in t){const a=r.ignoreCase?t=>t.data[e].toLowerCase().includes(n):t=>t.data[e].includes(n);if(0===t[n].length){o.push(this._getAllWithKeys().filter(a).map(e=>e.key).then(e=>({query:n,keys:e})));continue}const h=new Array(t[n].length);for(let e=0;e<t[n].length;e++)h[e]=this._readCursor(s.openCursor(t[n][e]),null,e=>e.key);const l=Promise.all(h).then(e=>{if(0===e.length)return Promise.resolve([]);e=i(e);const r=new Array(e.length);let s=0;const o={};for(let t=0;t<e.length;t++)e[t]in o||(o[e[t]]=0,r[s]=e[t],s++),o[e[t]]++;const a=new Array(s);let h=0;for(let e=0;e<s;e++)o[r[e]]>=t[n].length&&(a[h]=this.get(r[e]).then(t=>({key:r[e],data:t})),h++);return Promise.all(a.slice(0,h))}).then(e=>({query:n,keys:e.filter(a).map(e=>e.key)}));o.push(l)}return o}async _pruneCandidates(e,t){const r={};for(let e=0;e<t.length;e++)for(let n=0;n<t[e].keys.length;n++)t[e].keys[n]in r||(r[t[e].keys[n]]=new Set),r[t[e].keys[n]].add(t[e].query);const n=new Array(t.length);let s=0;for(let t in r)r[t].size==e&&(n[s]=this.get(t),s++);return await Promise.all(n.slice(0,s))}search(e,t,r={}){"string"==typeof e&&(e=[e]);for(let t=0;t<e.length;t++)if(!this.db.schema.ngramIndexes.has(e[t]))return c.reject(this.db.schema.indexes,new a(e[t]));const s=n(t=r.ignoreCase?t.toLowerCase():t);let i=0;for(let e in s)s[e]=o(s[e],e=>this._KeyRange.only(e)),i++;const h=[];for(let t=0;t<e.length;t++)Array.prototype.push.apply(h,this._takeCandidatesBySingleColumn(e[t],s,r));return new c(this.db.schema.indexes,Promise.all(h).then(e=>this._pruneCandidates(i,e)))}searchWord(e,r,n={}){"string"==typeof e&&(e=[e]);for(let t=0;t<e.length;t++)if(!this.db.schema.wordIndexes.has(e[t]))return c.reject(this.db.schema.indexes,new a(e[t]));const o=t(r=n.ignoreCase?r.toLowerCase():r).map(e=>({text:e,keyRange:this._KeyRange.only(e)}));return new c(this.db.schema.indexes,Promise.all(i(e.map(e=>{const t=this.transaction.objectStore(this.db.index_prefix+"word_"+e),r=n.ignoreCase?t.index("lower"):t.index("word");return o.map(e=>this._readCursor(r.openCursor(e.keyRange),null,t=>[t.key,e.text]))}))).then(e=>{e=s(i(e));const t={};for(let r=0;r<e.length;r++){const n=e[r][0];n in t||(t[n]=0),t[n]++}const r=new Array(e.length);let n=0;for(let s=0;s<e.length;s++){const i=e[s][0];t[i]>=o.length&&(r[n]=i,n++)}const a=new Array(n);for(let e=0;e<n;e++)a[e]=this.get(r[e]);return new c(this.db.schema.indexes,Promise.all(a))}))}_readIndexSet(e){const t=new Map;return new Promise((r,n)=>{const s=e.openKeyCursor();s.onsuccess=e=>{const n=e.target.result;n?(t.set(n.key,(t.get(n.key)||0)+1),n.continue()):r(t)},s.onerror=e=>n(e)})}getNGrams(e,t={}){if(!this.db.schema.ngramIndexes.has(e))return Promise.reject(new a(e));const r=this.transaction.objectStore(this.db.index_prefix+"ngram_"+e),n=t.ignoreCase?r.index("lower"):r.index("token");return this._readIndexSet(n)}getWords(e,t={}){if(!this.db.schema.wordIndexes.has(e))return Promise.reject(new a(e));const r=this.transaction.objectStore(this.db.index_prefix+"word_"+e),n=t.ignoreCase?r.index("lower"):r.index("word");return this._readIndexSet(n)}}function u(e){let t=null;for(const r in e){if(void 0!==e[r].primary){if("boolean"!=typeof e[r].primary)throw new l('"primary" option must be boolean',r);if(e[r].primary){if(null!==t)throw new l("can not use multiple primary key",[r,t]);t=r}}if(void 0!==e[r].unique&&"boolean"!=typeof e[r].unique)throw new l('"unique" option must be boolean',r);if(void 0!==e[r].normal&&"boolean"!=typeof e[r].normal)throw new l('"normal" option must be boolean',r);if(e[r].primary&&e[r].unique)throw new l('can not enable both of "primary" option and "unique" option to same column',r);if(e[r].primary&&e[r].normal)throw new l('can not enable both of "primary" option and "normal" option to same column',r);if(e[r].unique&&e[r].normal)throw new l('can not enable both of "unique" option and "normal" option to same column',r);if(void 0!==e[r].ngram&&void 0!==e[r].fulltext)throw new l('can not set both of "ngram" option and "fulltext" option to same column',r);const n=void 0===e[r].ngram?e[r].fulltext:e[r].ngram,s=void 0===e[r].ngram?"fulltext":"ngram";if(void 0!==n&&"boolean"!=typeof n)throw new l(`"${s}" option must be boolean`,r);if(void 0!==e[r].word&&"boolean"!=typeof e[r].word)throw new l('"word" option must be boolean',r)}}class m{constructor(e){this._schema=function(e){const t=new Set(["primary","unique","normal","ngram","fulltext","word"]),r={};for(const n in e)if(r[n]={},"object"==typeof e[n])for(const s in e[n]){if(!t.has(s))throw new l(s+" is unknown option",n);r[n][s]=e[n][s]}else{if("string"!=typeof e[n])throw new l(typeof e[n]+" is invalid option type",n);if(!t.has(e[n]))throw new l(e[n]+" is unknown option",n);r[n][e[n]]=!0}return r}(e),this._storeOption={autoIncrement:!0},this.primaryKey=null,this.ngramIndexes=new Set,this.wordIndexes=new Set,this.uniqueIndexes=new Set,this.normalIndexes=new Set;for(let t in e)u(this._schema),!0===this._schema[t].primary?(this.primaryKey=t,this._storeOption={keyPath:t}):!0===this._schema[t].unique?this.uniqueIndexes.add(t):!1!==this._schema[t].normal&&this.normalIndexes.add(t),(this._schema[t].ngram||this._schema[t].fulltext)&&this.ngramIndexes.add(t),this._schema[t].word&&this.wordIndexes.add(t)}get indexes(){return this.primaryKey?new Set([this.primaryKey,...this.uniqueIndexes,...this.normalIndexes]):new Set([...this.uniqueIndexes,...this.normalIndexes])}}e.IFTSArrayPromise=c,e.IFTSSchema=m,e.IFTSTransaction=d,e.IndexedFTS=class{constructor(e,t,r,n={}){this.index_prefix=n.index_prefix||"indexedfts_",this.scope=n.scope||window,this.name=e,this.version=t,this.schema=r instanceof m?r:new m(r),this.db=null}static delete(e,t=null){return new Promise((r,n)=>{const s=(t||window).indexedDB.deleteDatabase(e);s.onsuccess=e=>r(),s.onerror=e=>n(e)})}open(){return new Promise((e,t)=>{const r=this.scope.indexedDB.open(this.name,this.version);r.onsuccess=t=>{this.db=t.target.result,e(this)},r.onerror=t,r.onupgradeneeded=e=>{this.db=e.target.result;const r=this.db.createObjectStore("data",this.schema._storeOption);r.onerror=t,this.schema.uniqueIndexes.forEach(e=>r.createIndex(e,e,{unique:!0})),this.schema.normalIndexes.forEach(e=>r.createIndex(e,e,{unique:!1})),this.schema.ngramIndexes.forEach(e=>{const r=this.db.createObjectStore(this.index_prefix+"ngram_"+e,{autoIncrement:!0});r.onerror=t,r.createIndex("key","key",{unique:!1}),r.createIndex("token","token",{unique:!1}),r.createIndex("lower","lower",{unique:!1})}),this.schema.wordIndexes.forEach(e=>{const r=this.db.createObjectStore(this.index_prefix+"word_"+e,{autoIncrement:!0});r.onerror=t,r.createIndex("key","key",{unique:!1}),r.createIndex("word","word",{unique:!1}),r.createIndex("lower","lower",{unique:!1})})}})}close(){this.db.close()}transaction(e="readonly",t=null){if(null===t){const e=[...this.schema.ngramIndexes].map(e=>this.index_prefix+"ngram_"+e),r=[...this.schema.wordIndexes].map(e=>this.index_prefix+"word_"+e);t=e.concat(r).concat(["data"])}return new d(this,this.db.transaction(t,e))}put(...e){return this.transaction("readwrite").put(...e).then(()=>this)}delete(...e){return this.transaction("readwrite").delete(...e).then(()=>this)}get(e){return this.transaction("readonly","data").get(e)}_getFiltered(e){return e(this.transaction("readonly","data"))}getAll(){return this._getFiltered(e=>e.getAll())}map(e){return this._getFiltered(t=>t.map(e))}filter(e){return this._getFiltered(t=>t.filter(e))}sort(e,t="asc",r=0,n){return this._getFiltered(s=>s.sort(e,t,r,n))}equals(e,t){return this._getFiltered(r=>r.equals(e,t))}lower(e,t){return this._getFiltered(r=>r.lower(e,t))}greater(e,t){return this._getFiltered(r=>r.greater(e,t))}lowerOrEquals(e,t){return this._getFiltered(r=>r.lowerOrEquals(e,t))}greaterOrEquals(e,t){return this._getFiltered(r=>r.greaterOrEquals(e,t))}between(e,t,r){return this._getFiltered(n=>n.between(e,t,r))}search(e,t,r={}){return this.transaction().search(e,t,r)}searchWord(e,t,r={}){return this.transaction().searchWord(e,t,r)}getNGrams(e,t={}){return this.transaction().getNGrams(e,t)}getWords(e,t={}){return this.transaction().getWords(e,t)}},e.InvalidKeyError=h,e.InvalidSchemaError=l,e.NoSuchColumnError=a,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=indexedfts.min.js.map
