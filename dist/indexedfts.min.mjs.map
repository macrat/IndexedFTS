{"version":3,"file":"indexedfts.min.mjs","sources":["../lib/utils.js","../lib/errors.js","../lib/ArrayPromise.js","../lib/Transaction.js","../lib/Schema.js","../lib/IndexedFTS.js"],"sourcesContent":["/**\n * Splitting text to n-gram\n *\n * @ignore\n */\nexport function splitText(text, ngram=2) {\n\tconst result = [];\n\tfor (let i=0; i<text.length-ngram+1; i++) {\n\t\tresult.push(text.slice(i, i+ngram));\n\t}\n\treturn result;\n}\n\n\n/**\n * Splitting text to words\n *\n * @ignore\n */\nexport function splitWords(text) {\n\treturn dedup(text.split(/\\s+/).filter(x => x.length > 0));\n}\n\n\n/**\n * Make n-gram set by text.\n *\n * @ignore\n */\nexport function tokenize(text, ngram=2) {\n\treturn dedup(splitText(text, ngram));\n}\n\n\n/**\n * Parse queries.\n *\n * @ignore\n */\nexport function splitQuery(query, ngram=2) {\n\tconst result = {};\n\tquery.split(/\\s+/).filter(q => q.length > 0).forEach(q => result[q] = tokenize(q, ngram));\n\treturn result;\n}\n\n\n/**\n * Deduplication from Array\n *\n * @ignore\n */\nexport function dedup(array) {\n\tconst result = new Array(array.length);\n\tconst index = new Set();\n\tlet idx = 0;\n\n\tfor (let i=0; i<array.length; i++) {\n\t\tif (!index.has(array[i])) {\n\t\t\tindex.add(array[i]);\n\t\t\tresult[idx] = array[i];\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn result.slice(0, idx);\n}\n\n\n/**\n * Faster Array.prototype.map\n *\n * @ignore\n */\nexport function fastMap(array, fun) {\n\tconst result = new Array(array.length);\n\tfor (let i=0; i<array.length; i++) {\n\t\tresult[i] = fun(array[i]);\n\t}\n\treturn result;\n}\n\n\n/**\n * Flatten nested array\n *\n * @ignore\n */\nexport function flatten(array) {\n\tlet length = 0;\n\tfor (let i=0; i<array.length; i++) {\n\t\tlength += array[i].length;\n\t}\n\n\tconst result = new Array(length);\n\tlet idx = 0;\n\tfor (let i=0; i<array.length; i++) {\n\t\tfor (let j=0; j<array[i].length; j++) {\n\t\t\tresult[idx] = array[i][j];\n\t\t\tidx++;\n\t\t}\n\t}\n\n\treturn result;\n}\n","/**\n * NoSuchColumnError means specified no indexed column.\n */\nexport class NoSuchColumnError extends Error {\n\t/**\n\t * @param {object} column - name of errored column.\n\t */\n\tconstructor(column) {\n\t\tsuper(column + ': no such column or no indexed');\n\n\t\t/**\n\t\t * Column name that errored.\n\t\t *\n\t\t * @type {object}\n\t\t */\n\t\tthis.column = column;\n\n\t\t/** @ignore */\n\t\tthis.name = '';\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, NoSuchColumnError);\n\t\t}\n\t}\n}\n\n\n/**\n * InvalidKeyError means specified invalid key.\n */\nexport class InvalidKeyError extends Error {\n\t/**\n\t * @param {object} key - name of specified key.\n\t */\n\tconstructor(key) {\n\t\tsuper('invalid key');\n\n\t\t/**\n\t\t * Key name that specified.\n\t\t *\n\t\t * @type {object}\n\t\t */\n\t\tthis.key = key;\n\n\t\t/** @ignore */\n\t\tthis.name = '';\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, InvalidKeyError);\n\t\t}\n\t}\n}\n\n\n/**\n * InvalidSchemaError means specified invalid schema.\n */\nexport class InvalidSchemaError extends Error {\n\t/**\n\t * @param {string} reason - why throws this error.\n\t * @param {string|string[]|null} column - name of column that invalid.\n\t */\n\tconstructor(reason, column=null) {\n\t\tsuper(reason);\n\n\t\t/**\n\t\t * Name of column that invalid.\n\t\t *\n\t\t * @type {string|string[]|null}\n\t\t */\n\t\tthis.column = column;\n\n\t\t/** @ignore */\n\t\tthis.name = 'InvalidSchemaError';\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, InvalidSchemaError);\n\t\t}\n\t}\n}\n","import {splitQuery, splitWords} from './utils';\nimport {NoSuchColumnError} from './errors';\n\n\n/**\n * Promise like object for contents array.\n *\n * Almost methods are the same interface as {@link IndexedFTS} and {@link IFTSTransaction}.\n * But this class will processing all contents without using indexes.\n * Please consider using {@link IFTSTransaction} directly if it can.\n */\nexport default class IFTSArrayPromise {\n\t/**\n\t * @param {Set<string>} indexes - index names.\n\t * @param {Promise<object[]>} promise - Promise for wrapping.\n\t */\n\tconstructor(indexes, promise) {\n\t\t/** @type {Set<string>} */\n\t\tthis.indexes = indexes;\n\n\t\t/** @type {Promise<object[]>} */\n\t\tthis.promise = promise;\n\t}\n\n\t/**\n\t * Make resolved promise.\n\t *\n\t * @param {Set<string>} indexes - index names.\n\t * @param {object[]} value - value for promise.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tstatic resolve(indexes, value=[]) {\n\t\treturn new IFTSArrayPromise(indexes, Promise.resolve(value));\n\t}\n\n\t/**\n\t * Make rejected promise.\n\t *\n\t * @param {Set<string>} indexes - index names.\n\t * @param {object} value - value for promise.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tstatic reject(indexes, value=null) {\n\t\treturn new IFTSArrayPromise(indexes, Promise.reject(value));\n\t}\n\n\t/**\n\t * Set next function.\n\t *\n\t * @param {function(contents: object[]): *} fun - next function.\n\t *\n\t * @return {Promise}\n\t */\n\tthen(fun) {\n\t\treturn this.promise.then(fun);\n\t}\n\n\t/**\n\t * Set error handling function.\n\t *\n\t * @param {function(error: *): *} fun - error handling function.\n\t *\n\t * @return {Promise}\n\t */\n\tcatch(fun) {\n\t\treturn this.promise.catch(fun);\n\t}\n\n\t/**\n\t * Do something process for each elements and make a new IFTSArrayPromise.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for processing element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tmap(fun) {\n\t\treturn new IFTSArrayPromise(this.indexes, this.then(xs => xs.map(fun)));\n\t}\n\n\t/**\n\t * Filtering elements by function and make a new IFTSArrayPromise.\n\t *\n\t * @param {function(content: object, index: Number): boolean} fun - function for filtering element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tfilter(fun) {\n\t\treturn new IFTSArrayPromise(this.indexes, this.then(xs => xs.filter(fun)));\n\t}\n\n\t/**\n\t * Sort contents.\n\t *\n\t * @param {object} column - the column for sorting.\n\t * @param {'asc'|'desc'} [order='asc'] - sort order.\n\t * @param {Number} [offset=0] - starting offset of the result.\n\t * @param {Number} [limit] - maximum number of result length. will unlimited if omitted.\n\t *\n\t * @return {IFTSArrayPromise} sorted contents.\n\t */\n\tsort(column, order='asc', offset=0, limit=undefined) {\n\t\tif (!this.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\treturn new IFTSArrayPromise(this.indexes, this.then(xs => Array.prototype.concat.call([], xs).sort((x, y) => {\n\t\t\tif (x[column] < y[column]) {\n\t\t\t\treturn order === 'desc' ? 1 : -1;\n\t\t\t} else if (x[column] > y[column]) {\n\t\t\t\treturn order === 'desc' ? -1 : 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}).slice(offset, limit === undefined ? undefined : offset + limit)));\n\t}\n\n\t/**\n\t * Checking index of column are exists and do {@link IFTSArrayPromise#filter}.\n\t *\n\t * @ignore\n\t */\n\t_checkAndFilter(column, fun) {\n\t\tif (!this.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\treturn this.filter(fun);\n\t}\n\n\t/**\n\t * Get contents that have fully matched property.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tequals(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] === value);\n\t}\n\n\t/**\n\t * Get contents that have property lower than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlower(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] < value);\n\t}\n\n\t/**\n\t * Get contents that have property greater than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreater(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] > value);\n\t}\n\n\t/**\n\t * Get contents that have property lower than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlowerOrEquals(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] <= value);\n\t}\n\n\t/**\n\t * Get contents that have property greater than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreaterOrEquals(column, value) {\n\t\treturn this._checkAndFilter(column, x => x[column] >= value);\n\t}\n\n\t/**\n\t * Get contents that have property is between argument values.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} lower - minimal value.\n\t * @param {object} upper - maximum value.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tbetween(column, lower, upper) {\n\t\treturn this._checkAndFilter(column, x => lower <= x[column] && x[column] <= upper);\n\t}\n\n\t/**\n\t * Get contents that have matched property by full-text search.\n\t *\n\t * This method can search even if didn't made ngram index.\n\t *\n\t * WARNING: This method always processes all contents without using indexes.\n\t * Please consider using {@link IFTSTransaction#search}.\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case if true. default is false.\n\t *\n\t * @return {IFTSArrayPromise} matched contents.\n\t */\n\tsearch(columns, query, options={}) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let c of columns) {\n\t\t\tif (!this.indexes.has(c)) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(c));\n\t\t\t}\n\t\t}\n\n\t\tquery = options.ignoreCase ? query.toLowerCase() : query;\n\t\tconst queries = [];\n\t\tfor (let q in splitQuery(query)) {\n\t\t\tqueries.push(q);\n\t\t}\n\n\t\tconst toLowerIfNeed = options.ignoreCase ? (x => x.toLowerCase()) : (x => x);\n\n\t\treturn this.filter(data => queries.every(q => columns.some(col => toLowerIfNeed(data[col]).includes(q))));\n\t}\n\n\t/**\n\t * Find contents that have fully matched word in property.\n\t *\n\t * This method can search even if didn't made word index.\n\t *\n\t * WARNING: This method always processes all contents without using indexes.\n\t * Please consider using {@link IFTSTransaction#searchWord}.\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case if true. default is false.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearchWord(columns, query, options={}) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let c of columns) {\n\t\t\tif (!this.indexes.has(c)) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.indexes, new NoSuchColumnError(c));\n\t\t\t}\n\t\t}\n\n\t\tquery = options.ignoreCase ? query.toLowerCase() : query;\n\t\tconst queries = splitWords(query);\n\n\t\tconst toLowerIfNeed = options.ignoreCase ? (x => x.toLowerCase()) : (x => x);\n\n\t\treturn this.filter(data => queries.every(q => columns.some(col => {\n\t\t\treturn splitWords(toLowerIfNeed(data[col])).includes(q);\n\t\t})));\n\t}\n}\n","import {tokenize, splitQuery, splitWords, fastMap, flatten, dedup} from './utils';\nimport {NoSuchColumnError, InvalidKeyError} from './errors';\nimport IFTSArrayPromise from './ArrayPromise';\n\n\n/**\n * Transaction.\n *\n * Almost methods are the same interface as {@link IndexedFTS} and {@link IFTSArrayPromise}.\n * Probably this class is faster than other classes in most cases.\n *\n * Please be careful, IFTSTransaction are sometimes makes a big cache.\n * Should not keep many transactions if not need.\n */\nexport default class IFTSTransaction {\n\t/**\n\t * @param {IndexedFTS} db - database.\n\t * @param {IDBTransaction} transaction - transaction of IndexedDB.\n\t */\n\tconstructor(db, transaction) {\n\t\t/** @type {IndexedDB} */\n\t\tthis.db = db;\n\n\t\t/** @type {IDBTransaction} */\n\t\tthis.transaction = transaction;\n\n\t\t/** @ignore */\n\t\tthis._KeyRange = this.db.scope.IDBKeyRange;\n\n\t\t/**\n\t\t * Promise for await closing transaction.\n\t\t *\n\t\t * @type {Promise<IndexedDB>}\n\t\t */\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.transaction.oncomplete = () => resolve(this.db);\n\t\t\tthis.transaction.onerror = err => reject(err);\n\t\t});\n\n\t\t/** @ignore */\n\t\tthis._cache = {};\n\t}\n\n\t/**\n\t * Put contents into database.\n\t *\n\t * @param {object} contents - contents for save. allowed multiple arguments.\n\t *\n\t * @return {Promise<IFTSTransaction>} returns self for chain.\n\t */\n\tput(...contents) {\n\t\tconst store = this.transaction.objectStore('data');\n\t\tconst ngram_indexes = fastMap([...this.db.schema.ngramIndexes], column => ({name: column, store: this.transaction.objectStore(this.db.index_prefix + 'ngram_' + column)}));\n\t\tconst word_indexes = fastMap([...this.db.schema.wordIndexes], column => ({name: column, store: this.transaction.objectStore(this.db.index_prefix + 'word_' + column)}));\n\n\t\tconst putPromises = new Array(contents.length);\n\t\tfor (let i=0; i<contents.length; i++) {\n\t\t\tputPromises[i] = new Promise((resolve, reject) => {\n\t\t\t\tconst req = store.put(contents[i]);\n\t\t\t\treq.onerror = reject;\n\t\t\t\treq.onsuccess = ev => {\n\t\t\t\t\tresolve(\n\t\t\t\t\t\tthis._updateNGramIndex(ev.target.result, contents[i], ngram_indexes)\n\t\t\t\t\t\t\t.then(() => this._updateWordIndex(ev.target.result, contents[i], word_indexes)))\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\treturn Promise.all(putPromises).then(data => {\n\t\t\tfor (let i=0; i<data.length; i++) {\n\t\t\t\tconst key = data[i][0];\n\t\t\t\tconst value = data[i][1];\n\t\t\t\tif (this.db.schema.primaryKey === null) {\n\t\t\t\t\tvalue._key = key;\n\t\t\t\t}\n\t\t\t\tthis._cache[key] = value;\n\t\t\t}\n\t\t\treturn this;\n\t\t});\n\t}\n\n\t/**\n\t * Update ngram index.\n\t *\n\t * @ignore\n\t */\n\t_updateNGramIndex(key, data, ngram_indexes) {\n\t\treturn this._deleteIndex(key, ngram_indexes.map(x => this.db.index_prefix + 'ngram_' + x.name))\n\t\t\t.then(() => Promise.all(fastMap(ngram_indexes, col => {\n\t\t\t\tconst tokens = tokenize(data[col.name]);\n\t\t\t\tconst promises = new Array(tokens.length);\n\t\t\t\tfor (let i=0; i<tokens.length; i++) {\n\t\t\t\t\tpromises[i] = new Promise((resolve, reject) => {\n\t\t\t\t\t\tconst req = col.store.put({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\ttoken: tokens[i],\n\t\t\t\t\t\t\tlower: tokens[i].toLowerCase(),\n\t\t\t\t\t\t});\n\t\t\t\t\t\treq.onsuccess = () => resolve();\n\t\t\t\t\t\treq.onerror = reject;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn Promise.all(promises);\n\t\t\t})))\n\t\t\t.then(() => [key, data]);\n\t}\n\n\t/**\n\t * Update word index.\n\t *\n\t * @ignore\n\t */\n\t_updateWordIndex(key, data, word_indexes) {\n\t\treturn this._deleteIndex(key, word_indexes.map(x => this.db.index_prefix + 'word_' + x.name))\n\t\t\t.then(() => Promise.all(fastMap(word_indexes, col => {\n\t\t\t\tconst words = splitWords(data[col.name]);\n\t\t\t\tconst promises = new Array(words.length);\n\t\t\t\tfor (let i=0; i<words.length; i++) {\n\t\t\t\t\tpromises[i] = new Promise((resolve, reject) => {\n\t\t\t\t\t\tconst req = col.store.put({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tword: words[i],\n\t\t\t\t\t\t\tlower: words[i].toLowerCase(),\n\t\t\t\t\t\t});\n\t\t\t\t\t\treq.onsuccess = () => resolve();\n\t\t\t\t\t\treq.onerror = reject;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn Promise.all(promises);\n\t\t\t})))\n\t\t\t.then(() => [key, data]);\n\t}\n\n\t/**\n\t * Delete content by FTS indexes of database.\n\t *\n\t * @ignore\n\t */\n\t_deleteIndex(key, tableNames) {\n\t\treturn Promise.all(tableNames.map(table => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst store = this.transaction.objectStore(table);\n\t\t\t\tstore.onerror = reject;\n\n\t\t\t\tconst requests = [];\n\n\t\t\t\tconst req = store.index('key').openKeyCursor(this._KeyRange.only(key));\n\t\t\t\treq.onerror = reject;\n\t\t\t\treq.onsuccess = ev => {\n\t\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\trequests.push(new Promise((resolve, reject) => {\n\t\t\t\t\t\t\tconst d = store.delete(cursor.primaryKey);\n\t\t\t\t\t\t\td.onsuccess = resolve;\n\t\t\t\t\t\t\td.onerror = reject\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(Promise.all(requests));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}));\n\t}\n\n\t/**\n\t * Delete contents from database.\n\t *\n\t * @param {object} keys - key of contents. allowed multiple arguments.\n\t *\n\t * @return {Promise<IFTSTransaction>} returns self for chain. Will reject with {@link InvalidKeyError} if keys included null or undefined.\n\t */\n\tdelete(...keys) {\n\t\tfor (let i=0; i<keys.length; i++) {\n\t\t\tif (keys[i] === null || keys[i] === undefined) {\n\t\t\t\treturn Promise.reject(new InvalidKeyError(keys[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all(fastMap(keys, key => {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tconst req = this.transaction.objectStore('data').delete(key);\n\t\t\t\treq.onerror = reject;\n\t\t\t\treq.onsuccess = resolve;\n\t\t\t})\n\t\t\t.then(() => this._deleteIndex(key, [\n\t\t\t\t...[...this.db.schema.ngramIndexes].map(x => this.db.index_prefix + 'ngram_' + x),\n\t\t\t\t...[...this.db.schema.wordIndexes].map(x => this.db.index_prefix + 'word_' + x),\n\t\t\t]))\n\t\t})).then(() => this);\n\t}\n\n\t/**\n\t * Make {@link IFTSArrayPromise} by cursor.\n\t *\n\t * @ignore\n\t */\n\t_readCursor(cursorRequest, filter=null, map=null, limit=undefined) {\n\t\tfilter = filter || ((x, i) => true);\n\t\tmap = map || ((x, i) => x);\n\n\t\treturn new IFTSArrayPromise(this.db.schema.indexes, new Promise((resolve, reject) => {\n\t\t\tconst result = [];\n\t\t\tlet index = 0;\n\n\t\t\tcursorRequest.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tconst value = cursor.value;\n\t\t\t\t\tif (this.db.schema.primaryKey === null) {\n\t\t\t\t\t\tvalue._key = cursor.key;\n\t\t\t\t\t}\n\t\t\t\t\tthis._cache[cursor.key] = value;\n\t\t\t\t\tif (filter(value, index)) {\n\t\t\t\t\t\tresult.push(map(value, index));\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (limit === undefined || index < limit) {\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcursorRequest.onerror = err => reject(err);\n\t\t}));\n\t}\n\n\t/**\n\t * Get all contents.\n\t *\n\t * @return {IFTSArrayPromise} contents.\n\t */\n\tgetAll() {\n\t\treturn this._readCursor(this.transaction.objectStore('data').openCursor());\n\t}\n\n\t/**\n\t * Get all contents with primary keys.\n\t *\n\t * @ignore\n\t */\n\t_getAllWithKeys() {\n\t\treturn new IFTSArrayPromise(this.db.schema.indexes, new Promise((resolve, reject) => {\n\t\t\tconst request = this.transaction.objectStore('data').openCursor();\n\n\t\t\tconst result = [];\n\t\t\trequest.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tconst value = cursor.value;\n\t\t\t\t\tif (this.db.schema.primaryKey === null) {\n\t\t\t\t\t\tvalue._key = cursor.key;\n\t\t\t\t\t}\n\t\t\t\t\tthis._cache[cursor.key] = value;\n\t\t\t\t\tresult.push({key: cursor.key, data: value});\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\trequest.onerror = err => reject(err);\n\t\t}));\n\t}\n\n\t/**\n\t * Do something process for each elements and returns {@link IFTSArrayPromise}.\n\t *\n\t * NOTE: This method doesn't fast. May better do filtering before doing map if need filtering.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for processing element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tmap(fun) {\n\t\treturn this._readCursor(this.transaction.objectStore('data').openCursor(null), null, fun);\n\t}\n\n\t/**\n\t * Filtering elements by function and returns {@link IFTSArrayPromise}.\n\t *\n\t * WARNING: This method won't use the index. Other methods(eg. {@link IFTSTransaction#equals} or {@link IFTSTransaction#lower} may faster than this.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for filtering element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tfilter(fun) {\n\t\treturn this._readCursor(this.transaction.objectStore('data').openCursor(null), fun, null);\n\t}\n\n\t/**\n\t * Sort and get all contents.\n\t *\n\t * @param {object} column - the column for sorting.\n\t * @param {'asc'|'desc'} [order='asc'] - sort order.\n\t * @param {Number} [offset=0] - starting offset of the result.\n\t * @param {Number} [limit] - maximum number of result length. will unlimited if omitted.\n\t *\n\t * @return {IFTSArrayPromise} sorted contents.\n\t */\n\tsort(column, order='asc', offset=0, limit=undefined) {\n\t\tif (!this.db.schema.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.db.schema.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\tlimit = limit === undefined ? undefined : offset + limit;\n\t\tconst offsetFilter = (x, i) => offset <= i;\n\n\t\tconst store = this.transaction.objectStore('data');\n\n\t\tif (column === this.db.schema.primaryKey) {\n\t\t\treturn this._readCursor(store.openCursor(null, order === 'desc' ? 'prev' : 'next'), offsetFilter, null, limit);\n\t\t} else {\n\t\t\treturn this._readCursor(store.index(column).openCursor(null, order === 'desc' ? 'prev' : 'next'), offsetFilter, null, limit);\n\t\t}\n\t}\n\n\t/**\n\t * Get content by primary key.\n\t *\n\t * @param {object} key - the key of content.\n\t *\n\t * @return {Promise<object|undefined>} content. promise will reject with {@link InvalidKeyError} if keys included null or undefined. result value will be undefined if not found.\n\t */\n\tget(key) {\n\t\tif (key === null || key === undefined) {\n\t\t\treturn Promise.reject(new InvalidKeyError(key));\n\t\t}\n\t\tif (key in this._cache) {\n\t\t\treturn Promise.resolve(this._cache[key]);\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst req = this.transaction.objectStore('data').get(key);\n\t\t\treq.onsuccess = ev => {\n\t\t\t\tconst value = ev.target.result;\n\t\t\t\tif (this.db.schema.primaryKey === null) {\n\t\t\t\t\tvalue._key = key;\n\t\t\t\t}\n\t\t\t\tthis._cache[key] = value;\n\t\t\t\tresolve(value);\n\t\t\t};\n\t\t\treq.onerror = reject;\n\t\t});\n\t}\n\n\t/**\n\t * Get contents matched keyRange.\n\t *\n\t * @ignore\n\t */\n\t_getAllWithIndex(column, keyRange) {\n\t\tif (!this.db.schema.indexes.has(column)) {\n\t\t\treturn IFTSArrayPromise.reject(this.db.schema.indexes, new NoSuchColumnError(column));\n\t\t}\n\n\t\tconst store = this.transaction.objectStore('data');\n\n\t\tif (column === this.db.schema.primaryKey) {\n\t\t\treturn this._readCursor(store.openCursor(keyRange));\n\t\t} else {\n\t\t\treturn this._readCursor(store.index(column).openCursor(keyRange));\n\t\t}\n\t}\n\n\t/**\n\t * Get contents that have fully matched property.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tequals(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.only(value));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlower(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.upperBound(value, true));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreater(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.lowerBound(value, true));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlowerOrEquals(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.upperBound(value, false));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreaterOrEquals(column, value) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.lowerBound(value, false));\n\t}\n\n\t/**\n\t * Get contents that have property is between argument values.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} lower - minimal value.\n\t * @param {object} upper - maximum value.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tbetween(column, lower, upper) {\n\t\treturn this._getAllWithIndex(column, this._KeyRange.bound(lower, upper, false, false));\n\t}\n\n\t/**\n\t * Get candidates of search result.\n\t *\n\t * @ignore\n\t */\n\t_takeCandidatesBySingleColumn(column, queries, options={}) {\n\t\tconst store = this.transaction.objectStore(this.db.index_prefix + 'ngram_' + column);\n\t\tconst index = options.ignoreCase ? store.index('lower') : store.index('token');\n\t\tconst result = [];\n\n\t\tfor (let q in queries) {\n\t\t\tconst checkIncludes = (\n\t\t\t\toptions.ignoreCase\n\t\t\t\t\t? (x => x.data[column].toLowerCase().includes(q))\n\t\t\t\t\t: (x => x.data[column].includes(q))\n\t\t\t);\n\n\t\t\tif (queries[q].length === 0) {\n\t\t\t\tresult.push(this._getAllWithKeys().filter(checkIncludes).map(x => x.key).then(xs => ({query: q, keys: xs})));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst promises = new Array(queries[q].length);\n\t\t\tfor (let i=0; i<queries[q].length; i++) {\n\t\t\t\tpromises[i] = this._readCursor(index.openCursor(queries[q][i]), null, data => data.key);\n\t\t\t}\n\n\t\t\tconst candidate = Promise.all(promises)\n\t\t\t\t.then(founds => {\n\t\t\t\t\tif (founds.length === 0) {\n\t\t\t\t\t\treturn Promise.resolve([]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfounds = flatten(founds);\n\n\t\t\t\t\tconst deduped = new Array(founds.length);\n\t\t\t\t\tlet dedup_num = 0;\n\t\t\t\t\tconst hit_count = {};\n\t\t\t\t\tfor (let i=0; i<founds.length; i++) {\n\t\t\t\t\t\tif (!(founds[i] in hit_count)) {\n\t\t\t\t\t\t\thit_count[founds[i]] = 0;\n\n\t\t\t\t\t\t\tdeduped[dedup_num] = founds[i];\n\t\t\t\t\t\t\tdedup_num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thit_count[founds[i]]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst candidates = new Array(dedup_num);\n\t\t\t\t\tlet candidate_num = 0;\n\t\t\t\t\tfor (let i=0; i<dedup_num; i++) {\n\t\t\t\t\t\tif (hit_count[deduped[i]] >= queries[q].length) {\n\t\t\t\t\t\t\tcandidates[candidate_num] = this.get(deduped[i]).then(data => ({key: deduped[i], data: data}));\n\t\t\t\t\t\t\tcandidate_num++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Promise.all(candidates.slice(0, candidate_num));\n\t\t\t\t})\n\t\t\t\t.then(xs => ({query: q, keys: xs.filter(checkIncludes).map(x => x.key)}))\n\n\t\t\tresult.push(candidate);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Prune contents by result of {@link IFTSTransaction#_takeCandidatesBySingleColumn}.\n\t *\n\t * @ignore\n\t */\n\tasync _pruneCandidates(queries_num, candidates) {\n\t\tconst keys = {};\n\n\t\tfor (let i=0; i<candidates.length; i++) {\n\t\t\tfor (let j=0; j<candidates[i].keys.length; j++) {\n\t\t\t\tif (!(candidates[i].keys[j] in keys)) {\n\t\t\t\t\tkeys[candidates[i].keys[j]] = new Set();\n\t\t\t\t}\n\t\t\t\tkeys[candidates[i].keys[j]].add(candidates[i].query);\n\t\t\t}\n\t\t}\n\n\t\tconst result = new Array(candidates.length);\n\t\tlet result_num = 0;\n\t\tfor (let key in keys) {\n\t\t\tif (keys[key].size == queries_num) {\n\t\t\t\tresult[result_num] = this.get(key);\n\t\t\t\tresult_num++;\n\t\t\t}\n\t\t}\n\n\t\treturn await Promise.all(result.slice(0, result_num));\n\t}\n\n\t/**\n\t * Get contents that have matched property by full-text search.\n\t *\n\t * All target columns have to made ngram index when created database.\n\t * If you didn't made ngram index, you can use {@link IFTSArrayPromise#search} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case if true. default is false.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearch(columns, query, options={}) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let i=0; i<columns.length; i++) {\n\t\t\tif (!this.db.schema.ngramIndexes.has(columns[i])) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.db.schema.indexes, new NoSuchColumnError(columns[i]));\n\t\t\t}\n\t\t}\n\n\t\tquery = options.ignoreCase ? query.toLowerCase() : query;\n\t\tconst queries = splitQuery(query);\n\t\tlet queries_length = 0;\n\n\t\tfor (let q in queries) {\n\t\t\tqueries[q] = fastMap(queries[q], x => this._KeyRange.only(x));\n\t\t\tqueries_length++;\n\t\t}\n\n\t\tconst candidatePromises = [];\n\n\t\tfor (let i=0; i<columns.length; i++) {\n\t\t\tArray.prototype.push.apply(candidatePromises, this._takeCandidatesBySingleColumn(columns[i], queries, options));\n\t\t}\n\n\t\treturn new IFTSArrayPromise(\n\t\t\tthis.db.schema.indexes,\n\t\t\tPromise.all(candidatePromises).then(xs => this._pruneCandidates(queries_length, xs)),\n\t\t);\n\t}\n\n\t/**\n\t * Find contents that have fully matched word in property.\n\t *\n\t * All target columns have to made word index when created database.\n\t * If you didn't made word index, you can use {@link IFTSArrayPromise#searchWord} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case if true. default is false.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearchWord(columns, query, options={}) {\n\t\tif (typeof columns === 'string') {\n\t\t\tcolumns = [columns];\n\t\t}\n\n\t\tfor (let i=0; i<columns.length; i++) {\n\t\t\tif (!this.db.schema.wordIndexes.has(columns[i])) {\n\t\t\t\treturn IFTSArrayPromise.reject(this.db.schema.indexes, new NoSuchColumnError(columns[i]));\n\t\t\t}\n\t\t}\n\n\t\tquery = options.ignoreCase ? query.toLowerCase() : query;\n\t\tconst queries = splitWords(query).map(x => ({text: x, keyRange: this._KeyRange.only(x)}));\n\n\t\treturn new IFTSArrayPromise(this.db.schema.indexes, Promise.all(flatten(columns.map(col => {\n\t\t\tconst store = this.transaction.objectStore(this.db.index_prefix + 'word_' + col);\n\t\t\tconst index = options.ignoreCase ? store.index('lower') : store.index('word');\n\n\t\t\treturn queries.map(query => this._readCursor(index.openCursor(query.keyRange), null, data => [data.key, query.text]));\n\t\t}))).then(candidates => {\n\t\t\tcandidates = dedup(flatten(candidates));\n\n\t\t\tconst counts = {};\n\t\t\tfor (let i=0; i<candidates.length; i++) {\n\t\t\t\tconst key = candidates[i][0];\n\t\t\t\tif (!(key in counts)) {\n\t\t\t\t\tcounts[key] = 0;\n\t\t\t\t}\n\t\t\t\tcounts[key]++;\n\t\t\t}\n\n\t\t\tconst hits = new Array(candidates.length);\n\t\t\tlet hits_count = 0;\n\t\t\tfor (let i=0; i<candidates.length; i++) {\n\t\t\t\tconst key = candidates[i][0];\n\t\t\t\tif (counts[key] >= queries.length) {\n\t\t\t\t\thits[hits_count] = key;\n\t\t\t\t\thits_count++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = new Array(hits_count);\n\t\t\tfor (let i=0; i<hits_count; i++) {\n\t\t\t\tresult[i] = this.get(hits[i]);\n\t\t\t}\n\t\t\treturn new IFTSArrayPromise(this.db.schema.indexes, Promise.all(result));\n\t\t}));\n\t}\n\n\t/**\n\t * Make token set from index.\n\t *\n\t * @ignore\n\t */\n\t_readIndexSet(index) {\n\t\tconst result = new Map();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst cursor = index.openKeyCursor();\n\n\t\t\tcursor.onsuccess = ev => {\n\t\t\t\tconst cursor = ev.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tresult.set(cursor.key, (result.get(cursor.key) || 0) + 1);\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcursor.onerror = ev => reject(ev);\n\t\t});\n\t}\n\n\t/**\n\t * Get N-Gram set from index.\n\t *\n\t * @param {string} column - name of column.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case when make result.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetNGrams(column, options={}) {\n\t\tif (!this.db.schema.ngramIndexes.has(column)) {\n\t\t\treturn Promise.reject(new NoSuchColumnError(column));\n\t\t}\n\n\t\tconst store = this.transaction.objectStore(this.db.index_prefix + 'ngram_' + column);\n\t\tconst index = options.ignoreCase ? store.index('lower') : store.index('token');\n\n\t\treturn this._readIndexSet(index);\n\t}\n\n\t/**\n\t * Get word set from index.\n\t *\n\t * @param {string} column - name of column.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case when make result.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetWords(column, options={}) {\n\t\tif (!this.db.schema.wordIndexes.has(column)) {\n\t\t\treturn Promise.reject(new NoSuchColumnError(column));\n\t\t}\n\n\t\tconst store = this.transaction.objectStore(this.db.index_prefix + 'word_' + column);\n\t\tconst index = options.ignoreCase ? store.index('lower') : store.index('word');\n\n\t\treturn this._readIndexSet(index);\n\t}\n}\n","import {InvalidSchemaError} from './errors';\n\n\n/** @ignore */\nfunction normalize(schema) {\n\tconst allowedOptions = new Set(['primary', 'unique', 'normal', 'ngram', 'fulltext', 'word']);\n\n\tconst result = {};\n\tfor (const col in schema) {\n\t\tresult[col] = {};\n\n\t\tif (typeof schema[col] === 'object') {\n\t\t\tfor (const opt in schema[col]) {\n\t\t\t\tif (!allowedOptions.has(opt)) {\n\t\t\t\t\tthrow new InvalidSchemaError(opt + ' is unknown option', col);\n\t\t\t\t}\n\t\t\t\tresult[col][opt] = schema[col][opt];\n\t\t\t}\n\t\t} else if (typeof schema[col] === 'string') {\n\t\t\tif (!allowedOptions.has(schema[col])) {\n\t\t\t\tthrow new InvalidSchemaError(schema[col] + ' is unknown option', col);\n\t\t\t}\n\t\t\tresult[col][schema[col]] = true;\n\t\t} else {\n\t\t\tthrow new InvalidSchemaError((typeof schema[col]) + ' is invalid option type', col);\n\t\t}\n\t}\n\treturn result;\n}\n\n\n/** @ignore */\nfunction schemaCheck(schema) {\n\tlet primaryKey = null;\n\n\tfor (const col in schema) {\n\t\tif (schema[col].primary !== undefined) {\n\t\t\tif (typeof schema[col].primary !== 'boolean') {\n\t\t\t\tthrow new InvalidSchemaError('\"primary\" option must be boolean', col);\n\t\t\t}\n\t\t\tif (schema[col].primary) {\n\t\t\t\tif (primaryKey !== null) {\n\t\t\t\t\tthrow new InvalidSchemaError('can not use multiple primary key', [col, primaryKey]);\n\t\t\t\t}\n\t\t\t\tprimaryKey = col;\n\t\t\t}\n\t\t}\n\n\t\tif (schema[col].unique !== undefined) {\n\t\t\tif (typeof schema[col].unique !== 'boolean') {\n\t\t\t\tthrow new InvalidSchemaError('\"unique\" option must be boolean', col);\n\t\t\t}\n\t\t}\n\n\t\tif (schema[col].normal !== undefined) {\n\t\t\tif (typeof schema[col].normal !== 'boolean') {\n\t\t\t\tthrow new InvalidSchemaError('\"normal\" option must be boolean', col);\n\t\t\t}\n\t\t}\n\n\t\tif (schema[col].primary && schema[col].unique) {\n\t\t\tthrow new InvalidSchemaError('can not enable both of \"primary\" option and \"unique\" option to same column', col);\n\t\t}\n\t\tif (schema[col].primary && schema[col].normal) {\n\t\t\tthrow new InvalidSchemaError('can not enable both of \"primary\" option and \"normal\" option to same column', col);\n\t\t}\n\t\tif (schema[col].unique && schema[col].normal) {\n\t\t\tthrow new InvalidSchemaError('can not enable both of \"unique\" option and \"normal\" option to same column', col);\n\t\t}\n\n\t\tif (schema[col].ngram !== undefined && schema[col].fulltext !== undefined) {\n\t\t\tthrow new InvalidSchemaError('can not set both of \"ngram\" option and \"fulltext\" option to same column', col);\n\t\t}\n\t\tconst fts = schema[col].ngram === undefined ? schema[col].fulltext : schema[col].ngram;\n\t\tconst ftsFrom = schema[col].ngram === undefined ? 'fulltext' : 'ngram';\n\t\tif (fts !== undefined && typeof fts !== 'boolean') {\n\t\t\tthrow new InvalidSchemaError(`\"${ftsFrom}\" option must be boolean`, col);\n\t\t}\n\n\t\tif (schema[col].word !== undefined && typeof schema[col].word !== 'boolean') {\n\t\t\tthrow new InvalidSchemaError('\"word\" option must be boolean', col);\n\t\t}\n\t}\n}\n\n\nexport {normalize, schemaCheck};\n\n\n/**\n * The database schema of IndexedFTS.\n */\nexport default class IFTSSchema {\n\t/**\n\t * Create IFTSSchema.\n\t *\n\t * @param {object} schema - please see same name param of {@link IndexedFTS#constructor}.\n\t *\n\t * @throws {InvalidSchemaError}\n\t */\n\tconstructor(schema) {\n\t\t/** @ignore */\n\t\tthis._schema = normalize(schema);\n\n\t\t/** @ignore */\n\t\tthis._storeOption = {autoIncrement: true};\n\n\t\t/**\n\t\t * Primary key of this schema.\n\t\t *\n\t\t * This value will be null if not set primary key.\n\t\t *\n\t\t * @type {string|null}\n\t\t */\n\t\tthis.primaryKey = null;\n\n\t\t/**\n\t\t * Column names that indexed with ngram for full-text search.\n\t\t *\n\t\t * @type {Set<string>}\n\t\t */\n\t\tthis.ngramIndexes = new Set();\n\n\t\t/**\n\t\t * Column names that indexed with word for full-text search.\n\t\t *\n\t\t * @type {Set<string>}\n\t\t */\n\t\tthis.wordIndexes = new Set();\n\n\t\t/**\n\t\t * Column names that unique indexed.\n\t\t *\n\t\t * @type {Set<string>}\n\t\t */\n\t\tthis.uniqueIndexes = new Set();\n\n\t\t/**\n\t\t * Column names that normal indexed.\n\t\t *\n\t\t * @type {Set<string>}\n\t\t */\n\t\tthis.normalIndexes = new Set();\n\n\t\tfor (let x in schema) {\n\t\t\tschemaCheck(this._schema);\n\n\t\t\tif (this._schema[x].primary === true) {\n\t\t\t\tthis.primaryKey = x;\n\t\t\t\tthis._storeOption = {keyPath: x};\n\t\t\t} else if (this._schema[x].unique === true) {\n\t\t\t\tthis.uniqueIndexes.add(x);\n\t\t\t} else if (this._schema[x].normal !== false) {\n\t\t\t\tthis.normalIndexes.add(x);\n\t\t\t}\n\n\t\t\tif (this._schema[x].ngram || this._schema[x].fulltext) {\n\t\t\t\tthis.ngramIndexes.add(x);\n\t\t\t}\n\n\t\t\tif (this._schema[x].word) {\n\t\t\t\tthis.wordIndexes.add(x);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * All column names that indexed in some way.\n\t *\n\t * @type {Set<string>}\n\t */\n\tget indexes() {\n\t\tif (this.primaryKey) {\n\t\t\treturn new Set([this.primaryKey, ...this.uniqueIndexes, ...this.normalIndexes]);\n\t\t} else {\n\t\t\treturn new Set([...this.uniqueIndexes, ...this.normalIndexes]);\n\t\t}\n\t}\n}\n","import IFTSTransaction from './Transaction';\nimport IFTSSchema from './Schema';\n\n\n/**\n * The database of IndexedFTS.\n *\n * Almost methods are the same interface as {@link IDBTransaction} and {@link IFTSArrayPromise}.\n */\nexport default class IndexedFTS {\n\t/**\n\t * Create or open IndexedFTS.\n\t *\n\t * Database has name and schema's version.\n\t * The name is a name of the database in the storage.\n\t *\n\t * The schema is an object that key is column name and value is a definition of indexes. Schema can't change in same version database.\n\t * If you want change schema of database, please change version number.\n\t * Please be careful, all contents will remove when changing the version number.\n\t *\n\t * Index types are 'primary', 'unique', 'fulltext', 'ngram', 'word', or 'normal'.\n\t *\n\t * 'primary' is a primary key of the database. 'primary' can't set to multiple columns.\n\t * 'unique' is columns that have a unique value in the database.\n\t * The 'normal' will enable when not primary and not unique.\n\t * 'primary', 'unique' and 'normal' column can numeric search (eg. {@link IndexedFTS#lower} or {@link IndexedFTS#between}).\n\t *\n\t * If set 'ngram' IndexedFTS will make 2-gram index table for full-text search.\n\t * 'fulltext' is alias to 'ngram'.\n\t *\n\t * 'word' is word based index.\n\t * The word index will split text with whitespaces and store those.\n\t * Word index is faster than the 'ngram' index but can't find a partial match in the word.\n\t *\n\t * If you want to set some index types, please use object like `{unique: true, fulltext: true, normal: false}`.\n\t *\n\t * @param {string} name - name of new (or open) database.\n\t * @param {number} version - schema's version of database.\n\t * @param {object|IFTSSchema} schema - database schema.\n\t * @param {object} [options] - other options.\n\t * @param {string} [options.index_prefix='indexedfts_'] - prefix of indexes for full-text search.\n\t * @param {object} [options.scope=window] - endpoints for IndexedDB API.\n\t *\n\t * @throws {InvalidSchemaError}\n\t */\n\tconstructor(name, version, schema, options={}) {\n\t\t/** @type {string} */\n\t\tthis.index_prefix = options.index_prefix || 'indexedfts_';\n\n\t\t/** @type {object} */\n\t\tthis.scope = options.scope || window;\n\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\n\t\t/** @type {number} */\n\t\tthis.version = version;\n\n\t\t/** @type {IFTSSchema} */\n\t\tthis.schema = schema instanceof IFTSSchema ? schema : new IFTSSchema(schema);\n\n\n\t\t/** @type {IDBDatabase} */\n\t\tthis.db = null;\n\t}\n\n\t/**\n\t * Delete database.\n\t *\n\t * Must be close all IndexedFTS before delete database.\n\t *\n\t * @param {string} name - name of target database. this method will success even if no such database.\n\t * @param {object} [scope] - endpoints for IndexedDB API.\n\t *\n\t * @return {Promise<undefined>}\n\t */\n\tstatic delete(name, scope=null) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst req = (scope || window).indexedDB.deleteDatabase(name);\n\t\t\treq.onsuccess = ev => resolve();\n\t\t\treq.onerror = ev => reject(ev);\n\t\t});\n\t}\n\n\t/**\n\t * Open database.\n\t *\n\t * @return {Promise<undefined>}\n\t */\n\topen() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst request = this.scope.indexedDB.open(this.name, this.version);\n\n\t\t\trequest.onsuccess = ev => {\n\t\t\t\tthis.db = ev.target.result;\n\t\t\t\tresolve(this);\n\t\t\t};\n\t\t\trequest.onerror = reject;\n\n\t\t\trequest.onupgradeneeded = ev => {\n\t\t\t\tthis.db = ev.target.result;\n\n\t\t\t\tconst store = this.db.createObjectStore('data', this.schema._storeOption);\n\n\t\t\t\tstore.onerror = reject;\n\n\t\t\t\tthis.schema.uniqueIndexes.forEach(x => store.createIndex(x, x, {unique: true}));\n\n\t\t\t\tthis.schema.normalIndexes.forEach(x => store.createIndex(x, x, {unique: false}));\n\n\t\t\t\tthis.schema.ngramIndexes.forEach(column => {\n\t\t\t\t\tconst fts_store = this.db.createObjectStore(this.index_prefix + 'ngram_' + column, {autoIncrement: true});\n\t\t\t\t\tfts_store.onerror = reject\n\t\t\t\t\tfts_store.createIndex('key', 'key', {unique: false});\n\t\t\t\t\tfts_store.createIndex('token', 'token', {unique: false});\n\t\t\t\t\tfts_store.createIndex('lower', 'lower', {unique: false});\n\t\t\t\t});\n\n\t\t\t\tthis.schema.wordIndexes.forEach(column => {\n\t\t\t\t\tconst fts_store = this.db.createObjectStore(this.index_prefix + 'word_' + column, {autoIncrement: true});\n\t\t\t\t\tfts_store.onerror = reject\n\t\t\t\t\tfts_store.createIndex('key', 'key', {unique: false});\n\t\t\t\t\tfts_store.createIndex('word', 'word', {unique: false});\n\t\t\t\t\tfts_store.createIndex('lower', 'lower', {unique: false});\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Close database.\n\t */\n\tclose() {\n\t\tthis.db.close();\n\t}\n\n\t/**\n\t * Make new {@link IFTSTransaction}.\n\t *\n\t * @param {\"readonly\"|\"readwrite\"} mode - mode of transaction.\n\t * @param {string[]|null} target - open index targets. open for all if null.\n\t *\n\t * @return {IFTSTransaction}\n\t */\n\ttransaction(mode='readonly', target=null) {\n\t\tif (target === null) {\n\t\t\tconst ngrams = [...this.schema.ngramIndexes].map(x => this.index_prefix + 'ngram_' + x);\n\t\t\tconst words = [...this.schema.wordIndexes].map(x => this.index_prefix + 'word_' + x);\n\t\t\ttarget = ngrams.concat(words).concat(['data']);\n\t\t}\n\t\treturn new IFTSTransaction(this, this.db.transaction(target, mode));\n\t}\n\n\t/**\n\t * Put contents into database.\n\t *\n\t * @param {object} contents - contents for save. allowed multiple arguments.\n\t *\n\t * @return {Promise<IndexedFTS>} returns self for chain.\n\t */\n\tput(...contents) {\n\t\treturn this.transaction('readwrite').put(...contents).then(() => this);\n\t}\n\n\t/**\n\t * Delete contents from database.\n\t *\n\t * @param {object} keys - key of contents.\n\t *\n\t * @return {Promise<IndexedFTS>} returns self for chain. Will reject with {@link InvalidKeyError} if keys included null or undefined.\n\t */\n\tdelete(...keys) {\n\t\treturn this.transaction('readwrite').delete(...keys).then(() => this);\n\t}\n\n\t/**\n\t * Get content by primary key.\n\t *\n\t * @param {object} key - the key of content.\n\t *\n\t * @return {Promise<object|undefined>} content. promise will reject with {@link InvalidKeyError} if keys included null or undefined. result value will be undefined if not found.\n\t */\n\tget(key) {\n\t\treturn this.transaction('readonly', 'data').get(key);\n\t}\n\n\t/**\n\t * Get filtered contents.\n\t *\n\t * @ignore\n\t */\n\t_getFiltered(fun) {\n\t\treturn fun(this.transaction('readonly', 'data'));\n\t}\n\n\t/**\n\t * Get all contents.\n\t *\n\t * @return {IFTSArrayPromise} contents.\n\t */\n\tgetAll() {\n\t\treturn this._getFiltered(x => x.getAll());\n\t}\n\n\t/**\n\t * Do something process for each elements and returns {@link IFTSArrayPromise}.\n\t *\n\t * NOTE: This method doesn't fast. May better do filtering before doing map if need filtering.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for processing element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tmap(fun) {\n\t\treturn this._getFiltered(x => x.map(fun));\n\t}\n\n\t/**\n\t * Filtering elements by function and returns {@link IFTSArrayPromise}.\n\t *\n\t * WARNING: This method won't use the index. Other methods(eg. {@link IFTSTransaction#equals or @link IFTSTransaction#lower} may faster than this.\n\t *\n\t * @param {function(content: object, index: Number): object} fun - function for filtering element.\n\t *\n\t * @return {IFTSArrayPromise}\n\t */\n\tfilter(fun) {\n\t\treturn this._getFiltered(x => x.filter(fun));\n\t}\n\n\t/**\n\t * Sort and get all contents.\n\t *\n\t * @param {object} column - the column for sorting.\n\t * @param {'asc'|'desc'} [order='asc'] - sort order.\n\t * @param {Number} [offset=0] - starting offset of the result.\n\t * @param {Number} [limit] - maximum number of result length. will unlimited if omitted.\n\t *\n\t * @return {IFTSArrayPromise} sorted contents.\n\t */\n\tsort(column, order='asc', offset=0, limit=undefined) {\n\t\treturn this._getFiltered(x => x.sort(column, order, offset, limit));\n\t}\n\n\t/**\n\t * Get contents that have fully matched property.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tequals(column, value) {\n\t\treturn this._getFiltered(x => x.equals(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlower(column, value) {\n\t\treturn this._getFiltered(x => x.lower(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreater(column, value) {\n\t\treturn this._getFiltered(x => x.greater(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property lower than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tlowerOrEquals(column, value) {\n\t\treturn this._getFiltered(x => x.lowerOrEquals(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property greater than value or equals value.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} value - value for search.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tgreaterOrEquals(column, value) {\n\t\treturn this._getFiltered(x => x.greaterOrEquals(column, value));\n\t}\n\n\t/**\n\t * Get contents that have property is between argument values.\n\t *\n\t * @param {object} column - column name for search.\n\t * @param {object} lower - minimal value.\n\t * @param {object} upper - maximum value.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tbetween(column, lower, upper) {\n\t\treturn this._getFiltered(x => x.between(column, lower, upper));\n\t}\n\n\t/**\n\t * Get contents that have matched property by full-text search.\n\t *\n\t * All target columns have to made ngram index when created database.\n\t * If you didn't made ngram index, you can use {@link IFTSArrayPromise#search} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case if true. default is false.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearch(columns, query, options={}) {\n\t\treturn this.transaction().search(columns, query, options);\n\t}\n\n\t/**\n\t * Find contents that have fully matched word in property.\n\t *\n\t * All target columns have to made word index when created database.\n\t * If you didn't made word index, you can use {@link IFTSArrayPromise#searchWord} (but this way is very slow).\n\t *\n\t *\n\t * @param {object|object[]} columns - column names for search.\n\t * @param {string} query - query for search.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case if true. default is false.\n\t *\n\t * @return {IFTSArrayPromise} matched contents. may reject with {@link NoSuchColumnError}.\n\t */\n\tsearchWord(columns, query, options={}) {\n\t\treturn this.transaction().searchWord(columns, query, options);\n\t}\n\n\t/**\n\t * Get N-Gram set from index.\n\t *\n\t * @param {string} column - name of column.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case when make result.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetNGrams(column, options={}) {\n\t\treturn this.transaction().getNGrams(column, options);\n\t}\n\n\t/**\n\t * Get word set from index.\n\t *\n\t * @param {string} column - name of column.\n\t * @param {object} [options] - optional arguments.\n\t * @param {boolean} [options.ignoreCase=false] - ignore case when make result.\n\t *\n\t * @return {Promise<Map<string, number>>}\n\t */\n\tgetWords(column, options={}) {\n\t\treturn this.transaction().getWords(column, options);\n\t}\n}\n"],"names":["splitWords","text","dedup","split","filter","x","length","tokenize","ngram","result","i","push","slice","splitText","splitQuery","query","q","forEach","array","Array","index","Set","idx","has","add","fastMap","fun","flatten","j","NoSuchColumnError","Error","constructor","column","name","captureStackTrace","this","InvalidKeyError","key","InvalidSchemaError","reason","IFTSArrayPromise","indexes","promise","value","Promise","resolve","reject","then","catch","map","xs","sort","order","offset","limit","prototype","concat","call","y","undefined","_checkAndFilter","equals","lower","greater","lowerOrEquals","greaterOrEquals","between","upper","search","columns","options","c","ignoreCase","toLowerCase","queries","toLowerIfNeed","data","every","some","col","includes","searchWord","IFTSTransaction","db","transaction","_KeyRange","scope","IDBKeyRange","oncomplete","onerror","err","_cache","put","contents","store","objectStore","ngram_indexes","schema","ngramIndexes","index_prefix","word_indexes","wordIndexes","putPromises","req","onsuccess","ev","_updateNGramIndex","target","_updateWordIndex","all","primaryKey","_key","_deleteIndex","tokens","promises","token","words","word","tableNames","table","requests","openKeyCursor","only","cursor","d","delete","continue","keys","_readCursor","cursorRequest","getAll","openCursor","_getAllWithKeys","request","offsetFilter","get","_getAllWithIndex","keyRange","upperBound","lowerBound","bound","_takeCandidatesBySingleColumn","checkIncludes","candidate","founds","deduped","dedup_num","hit_count","candidates","candidate_num","queries_num","result_num","size","queries_length","candidatePromises","apply","_pruneCandidates","counts","hits","hits_count","_readIndexSet","Map","set","getNGrams","getWords","schemaCheck","primary","unique","normal","fulltext","fts","ftsFrom","IFTSSchema","_schema","allowedOptions","opt","normalize","_storeOption","autoIncrement","uniqueIndexes","normalIndexes","keyPath","version","window","indexedDB","deleteDatabase","open","onupgradeneeded","createObjectStore","createIndex","fts_store","close","mode","ngrams","_getFiltered"],"mappings":"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"}